# coding: utf-8

"""
    Knetik Platform API Documentation latest 

    This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com.

    OpenAPI spec version: latest 
    Contact: support@knetik.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..api_client import ApiClient


class GamificationAchievementsApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_achievement(self, **kwargs):
        """
        Create a new achievement definition
        If the definition contains a trigger event name, a BRE rule is created, so that tracking logic is executed when the triggering event occurs. If no trigger event name is specified, the user's achievement status must manually be updated via the API.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_achievement(async=True)
        >>> result = thread.get()

        :param async bool
        :param AchievementDefinitionResource achievement: The achievement definition
        :return: AchievementDefinitionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_achievement_with_http_info(**kwargs)
        else:
            (data) = self.create_achievement_with_http_info(**kwargs)
            return data

    def create_achievement_with_http_info(self, **kwargs):
        """
        Create a new achievement definition
        If the definition contains a trigger event name, a BRE rule is created, so that tracking logic is executed when the triggering event occurs. If no trigger event name is specified, the user's achievement status must manually be updated via the API.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_achievement_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param AchievementDefinitionResource achievement: The achievement definition
        :return: AchievementDefinitionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['achievement']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_achievement" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'achievement' in params:
            body_params = params['achievement']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/achievements', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AchievementDefinitionResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_achievement_template(self, **kwargs):
        """
        Create an achievement template
        Achievement templates define a type of achievement and the properties they have
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_achievement_template(async=True)
        >>> result = thread.get()

        :param async bool
        :param TemplateResource template: The achievement template to be created
        :return: TemplateResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_achievement_template_with_http_info(**kwargs)
        else:
            (data) = self.create_achievement_template_with_http_info(**kwargs)
            return data

    def create_achievement_template_with_http_info(self, **kwargs):
        """
        Create an achievement template
        Achievement templates define a type of achievement and the properties they have
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_achievement_template_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param TemplateResource template: The achievement template to be created
        :return: TemplateResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['template']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_achievement_template" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'template' in params:
            body_params = params['template']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/achievements/templates', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TemplateResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_achievement(self, name, **kwargs):
        """
        Delete an achievement definition
        Will also disable the associated generated rule, if any.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_achievement(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: The name of the achievement (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_achievement_with_http_info(name, **kwargs)
        else:
            (data) = self.delete_achievement_with_http_info(name, **kwargs)
            return data

    def delete_achievement_with_http_info(self, name, **kwargs):
        """
        Delete an achievement definition
        Will also disable the associated generated rule, if any.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_achievement_with_http_info(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: The name of the achievement (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_achievement" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_achievement`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/achievements/{name}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_achievement_template(self, id, **kwargs):
        """
        Delete an achievement template
        If cascade = 'detach', it will force delete the template even if it's attached to other objects
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_achievement_template(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the template (required)
        :param str cascade: The value needed to delete used templates
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_achievement_template_with_http_info(id, **kwargs)
        else:
            (data) = self.delete_achievement_template_with_http_info(id, **kwargs)
            return data

    def delete_achievement_template_with_http_info(self, id, **kwargs):
        """
        Delete an achievement template
        If cascade = 'detach', it will force delete the template even if it's attached to other objects
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_achievement_template_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the template (required)
        :param str cascade: The value needed to delete used templates
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'cascade']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_achievement_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_achievement_template`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'cascade' in params:
            query_params.append(('cascade', params['cascade']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/achievements/templates/{id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_achievement(self, name, **kwargs):
        """
        Get a single achievement definition
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_achievement(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: The name of the achievement (required)
        :return: AchievementDefinitionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_achievement_with_http_info(name, **kwargs)
        else:
            (data) = self.get_achievement_with_http_info(name, **kwargs)
            return data

    def get_achievement_with_http_info(self, name, **kwargs):
        """
        Get a single achievement definition
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_achievement_with_http_info(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: The name of the achievement (required)
        :return: AchievementDefinitionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_achievement" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_achievement`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/achievements/{name}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AchievementDefinitionResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_achievement_template(self, id, **kwargs):
        """
        Get a single achievement template
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_achievement_template(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the template (required)
        :return: TemplateResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_achievement_template_with_http_info(id, **kwargs)
        else:
            (data) = self.get_achievement_template_with_http_info(id, **kwargs)
            return data

    def get_achievement_template_with_http_info(self, id, **kwargs):
        """
        Get a single achievement template
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_achievement_template_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the template (required)
        :return: TemplateResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_achievement_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_achievement_template`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/achievements/templates/{id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TemplateResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_achievement_templates(self, **kwargs):
        """
        List and search achievement templates
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_achievement_templates(async=True)
        >>> result = thread.get()

        :param async bool
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :param str order: A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
        :return: PageResourceTemplateResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_achievement_templates_with_http_info(**kwargs)
        else:
            (data) = self.get_achievement_templates_with_http_info(**kwargs)
            return data

    def get_achievement_templates_with_http_info(self, **kwargs):
        """
        List and search achievement templates
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_achievement_templates_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :param str order: A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
        :return: PageResourceTemplateResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['size', 'page', 'order']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_achievement_templates" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'size' in params:
            query_params.append(('size', params['size']))
        if 'page' in params:
            query_params.append(('page', params['page']))
        if 'order' in params:
            query_params.append(('order', params['order']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/achievements/templates', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PageResourceTemplateResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_achievement_triggers(self, **kwargs):
        """
        Get the list of triggers that can be used to trigger an achievement progress update
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_achievement_triggers(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[BreTriggerResource]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_achievement_triggers_with_http_info(**kwargs)
        else:
            (data) = self.get_achievement_triggers_with_http_info(**kwargs)
            return data

    def get_achievement_triggers_with_http_info(self, **kwargs):
        """
        Get the list of triggers that can be used to trigger an achievement progress update
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_achievement_triggers_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[BreTriggerResource]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_achievement_triggers" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/achievements/triggers', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[BreTriggerResource]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_achievements(self, **kwargs):
        """
        Get all achievement definitions in the system
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_achievements(async=True)
        >>> result = thread.get()

        :param async bool
        :param str filter_tagset: Filter for achievements with specified tags (separated by comma)
        :param str filter_name: Filter for achievements whose name contains a string
        :param bool filter_hidden: Filter for achievements that are hidden or not
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :param str order: A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
        :param bool filter_derived: Filter for achievements that are derived from other services
        :return: PageResourceAchievementDefinitionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_achievements_with_http_info(**kwargs)
        else:
            (data) = self.get_achievements_with_http_info(**kwargs)
            return data

    def get_achievements_with_http_info(self, **kwargs):
        """
        Get all achievement definitions in the system
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_achievements_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str filter_tagset: Filter for achievements with specified tags (separated by comma)
        :param str filter_name: Filter for achievements whose name contains a string
        :param bool filter_hidden: Filter for achievements that are hidden or not
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :param str order: A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
        :param bool filter_derived: Filter for achievements that are derived from other services
        :return: PageResourceAchievementDefinitionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter_tagset', 'filter_name', 'filter_hidden', 'size', 'page', 'order', 'filter_derived']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_achievements" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter_tagset' in params:
            query_params.append(('filter_tagset', params['filter_tagset']))
        if 'filter_name' in params:
            query_params.append(('filter_name', params['filter_name']))
        if 'filter_hidden' in params:
            query_params.append(('filter_hidden', params['filter_hidden']))
        if 'size' in params:
            query_params.append(('size', params['size']))
        if 'page' in params:
            query_params.append(('page', params['page']))
        if 'order' in params:
            query_params.append(('order', params['order']))
        if 'filter_derived' in params:
            query_params.append(('filter_derived', params['filter_derived']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/achievements', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PageResourceAchievementDefinitionResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_derived_achievements(self, name, **kwargs):
        """
        Get a list of derived achievements
        Used by other services that depend on achievements
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_derived_achievements(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: The name of the derived achievement (required)
        :return: list[AchievementDefinitionResource]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_derived_achievements_with_http_info(name, **kwargs)
        else:
            (data) = self.get_derived_achievements_with_http_info(name, **kwargs)
            return data

    def get_derived_achievements_with_http_info(self, name, **kwargs):
        """
        Get a list of derived achievements
        Used by other services that depend on achievements
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_derived_achievements_with_http_info(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: The name of the derived achievement (required)
        :return: list[AchievementDefinitionResource]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_derived_achievements" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_derived_achievements`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/achievements/derived/{name}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[AchievementDefinitionResource]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_user_achievement_progress(self, user_id, achievement_name, **kwargs):
        """
        Retrieve progress on a given achievement for a given user
        Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_user_achievement_progress(user_id, achievement_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The user's id (required)
        :param str achievement_name: The achievement's name (required)
        :return: UserAchievementGroupResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_user_achievement_progress_with_http_info(user_id, achievement_name, **kwargs)
        else:
            (data) = self.get_user_achievement_progress_with_http_info(user_id, achievement_name, **kwargs)
            return data

    def get_user_achievement_progress_with_http_info(self, user_id, achievement_name, **kwargs):
        """
        Retrieve progress on a given achievement for a given user
        Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_user_achievement_progress_with_http_info(user_id, achievement_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The user's id (required)
        :param str achievement_name: The achievement's name (required)
        :return: UserAchievementGroupResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'achievement_name']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_achievement_progress" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `get_user_achievement_progress`")
        # verify the required parameter 'achievement_name' is set
        if ('achievement_name' not in params) or (params['achievement_name'] is None):
            raise ValueError("Missing the required parameter `achievement_name` when calling `get_user_achievement_progress`")


        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']
        if 'achievement_name' in params:
            path_params['achievement_name'] = params['achievement_name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/users/{user_id}/achievements/{achievement_name}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='UserAchievementGroupResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_user_achievements_progress(self, user_id, **kwargs):
        """
        Retrieve progress on achievements for a given user
        Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_user_achievements_progress(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The user's id (required)
        :param bool filter_achievement_derived: Filter for achievements that are derived from other services
        :param str filter_achievement_tagset: Filter for achievements with specified tags (separated by comma)
        :param str filter_achievement_name: Filter for achievements whose name contains a string
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :return: PageResourceUserAchievementGroupResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_user_achievements_progress_with_http_info(user_id, **kwargs)
        else:
            (data) = self.get_user_achievements_progress_with_http_info(user_id, **kwargs)
            return data

    def get_user_achievements_progress_with_http_info(self, user_id, **kwargs):
        """
        Retrieve progress on achievements for a given user
        Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_user_achievements_progress_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The user's id (required)
        :param bool filter_achievement_derived: Filter for achievements that are derived from other services
        :param str filter_achievement_tagset: Filter for achievements with specified tags (separated by comma)
        :param str filter_achievement_name: Filter for achievements whose name contains a string
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :return: PageResourceUserAchievementGroupResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'filter_achievement_derived', 'filter_achievement_tagset', 'filter_achievement_name', 'size', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_achievements_progress" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `get_user_achievements_progress`")


        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = []
        if 'filter_achievement_derived' in params:
            query_params.append(('filter_achievement_derived', params['filter_achievement_derived']))
        if 'filter_achievement_tagset' in params:
            query_params.append(('filter_achievement_tagset', params['filter_achievement_tagset']))
        if 'filter_achievement_name' in params:
            query_params.append(('filter_achievement_name', params['filter_achievement_name']))
        if 'size' in params:
            query_params.append(('size', params['size']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/users/{user_id}/achievements', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PageResourceUserAchievementGroupResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_users_achievement_progress(self, achievement_name, **kwargs):
        """
        Retrieve progress on a given achievement for all users
        Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_users_achievement_progress(achievement_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str achievement_name: The achievement's name (required)
        :param bool filter_achievement_derived: Filter for achievements that are derived from other services
        :param str filter_achievement_tagset: Filter for achievements with specified tags (separated by comma)
        :param str filter_achievement_name: Filter for achievements whose name contains a string
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :return: PageResourceUserAchievementGroupResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_users_achievement_progress_with_http_info(achievement_name, **kwargs)
        else:
            (data) = self.get_users_achievement_progress_with_http_info(achievement_name, **kwargs)
            return data

    def get_users_achievement_progress_with_http_info(self, achievement_name, **kwargs):
        """
        Retrieve progress on a given achievement for all users
        Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_users_achievement_progress_with_http_info(achievement_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str achievement_name: The achievement's name (required)
        :param bool filter_achievement_derived: Filter for achievements that are derived from other services
        :param str filter_achievement_tagset: Filter for achievements with specified tags (separated by comma)
        :param str filter_achievement_name: Filter for achievements whose name contains a string
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :return: PageResourceUserAchievementGroupResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['achievement_name', 'filter_achievement_derived', 'filter_achievement_tagset', 'filter_achievement_name', 'size', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_users_achievement_progress" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'achievement_name' is set
        if ('achievement_name' not in params) or (params['achievement_name'] is None):
            raise ValueError("Missing the required parameter `achievement_name` when calling `get_users_achievement_progress`")


        collection_formats = {}

        path_params = {}
        if 'achievement_name' in params:
            path_params['achievement_name'] = params['achievement_name']

        query_params = []
        if 'filter_achievement_derived' in params:
            query_params.append(('filter_achievement_derived', params['filter_achievement_derived']))
        if 'filter_achievement_tagset' in params:
            query_params.append(('filter_achievement_tagset', params['filter_achievement_tagset']))
        if 'filter_achievement_name' in params:
            query_params.append(('filter_achievement_name', params['filter_achievement_name']))
        if 'size' in params:
            query_params.append(('size', params['size']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/users/achievements/{achievement_name}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PageResourceUserAchievementGroupResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_users_achievements_progress(self, **kwargs):
        """
        Retrieve progress on achievements for all users
        Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_users_achievements_progress(async=True)
        >>> result = thread.get()

        :param async bool
        :param bool filter_achievement_derived: Filter for achievements that are derived from other services
        :param str filter_achievement_tagset: Filter for achievements with specified tags (separated by comma)
        :param str filter_achievement_name: Filter for achievements whose name contains a string
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :return: PageResourceUserAchievementGroupResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_users_achievements_progress_with_http_info(**kwargs)
        else:
            (data) = self.get_users_achievements_progress_with_http_info(**kwargs)
            return data

    def get_users_achievements_progress_with_http_info(self, **kwargs):
        """
        Retrieve progress on achievements for all users
        Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_users_achievements_progress_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param bool filter_achievement_derived: Filter for achievements that are derived from other services
        :param str filter_achievement_tagset: Filter for achievements with specified tags (separated by comma)
        :param str filter_achievement_name: Filter for achievements whose name contains a string
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :return: PageResourceUserAchievementGroupResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter_achievement_derived', 'filter_achievement_tagset', 'filter_achievement_name', 'size', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_users_achievements_progress" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter_achievement_derived' in params:
            query_params.append(('filter_achievement_derived', params['filter_achievement_derived']))
        if 'filter_achievement_tagset' in params:
            query_params.append(('filter_achievement_tagset', params['filter_achievement_tagset']))
        if 'filter_achievement_name' in params:
            query_params.append(('filter_achievement_name', params['filter_achievement_name']))
        if 'size' in params:
            query_params.append(('size', params['size']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/users/achievements', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PageResourceUserAchievementGroupResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def increment_achievement_progress(self, user_id, achievement_name, **kwargs):
        """
        Increment an achievement progress record for a user
        If no progress record yet exists for the user, it will be created. Otherwise it will be updated and the provided value added to the existing progress. May be negative. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.increment_achievement_progress(user_id, achievement_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The user's id (required)
        :param str achievement_name: The achievement's name (required)
        :param IntWrapper progress: The amount to add to the progress value
        :return: UserAchievementGroupResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.increment_achievement_progress_with_http_info(user_id, achievement_name, **kwargs)
        else:
            (data) = self.increment_achievement_progress_with_http_info(user_id, achievement_name, **kwargs)
            return data

    def increment_achievement_progress_with_http_info(self, user_id, achievement_name, **kwargs):
        """
        Increment an achievement progress record for a user
        If no progress record yet exists for the user, it will be created. Otherwise it will be updated and the provided value added to the existing progress. May be negative. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.increment_achievement_progress_with_http_info(user_id, achievement_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The user's id (required)
        :param str achievement_name: The achievement's name (required)
        :param IntWrapper progress: The amount to add to the progress value
        :return: UserAchievementGroupResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'achievement_name', 'progress']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method increment_achievement_progress" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `increment_achievement_progress`")
        # verify the required parameter 'achievement_name' is set
        if ('achievement_name' not in params) or (params['achievement_name'] is None):
            raise ValueError("Missing the required parameter `achievement_name` when calling `increment_achievement_progress`")


        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']
        if 'achievement_name' in params:
            path_params['achievement_name'] = params['achievement_name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'progress' in params:
            body_params = params['progress']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/users/{user_id}/achievements/{achievement_name}/progress', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='UserAchievementGroupResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def set_achievement_progress(self, user_id, achievement_name, **kwargs):
        """
        Set an achievement progress record for a user
        If no progress record yet exists for the user, it will be created. Otherwise it will be updated and progress set to the provided value. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_achievement_progress(user_id, achievement_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The user's id (required)
        :param str achievement_name: The achievement's name (required)
        :param IntWrapper progress: The new progress value
        :return: UserAchievementGroupResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.set_achievement_progress_with_http_info(user_id, achievement_name, **kwargs)
        else:
            (data) = self.set_achievement_progress_with_http_info(user_id, achievement_name, **kwargs)
            return data

    def set_achievement_progress_with_http_info(self, user_id, achievement_name, **kwargs):
        """
        Set an achievement progress record for a user
        If no progress record yet exists for the user, it will be created. Otherwise it will be updated and progress set to the provided value. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_achievement_progress_with_http_info(user_id, achievement_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The user's id (required)
        :param str achievement_name: The achievement's name (required)
        :param IntWrapper progress: The new progress value
        :return: UserAchievementGroupResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'achievement_name', 'progress']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_achievement_progress" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `set_achievement_progress`")
        # verify the required parameter 'achievement_name' is set
        if ('achievement_name' not in params) or (params['achievement_name'] is None):
            raise ValueError("Missing the required parameter `achievement_name` when calling `set_achievement_progress`")


        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']
        if 'achievement_name' in params:
            path_params['achievement_name'] = params['achievement_name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'progress' in params:
            body_params = params['progress']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/users/{user_id}/achievements/{achievement_name}/progress', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='UserAchievementGroupResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_achievement(self, name, **kwargs):
        """
        Update an achievement definition
        The existing generated rule, if any, will be deleted. A new rule will be created if a trigger event name is specified in the new version.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_achievement(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: The name of the achievement (required)
        :param AchievementDefinitionResource achievement: The achievement definition
        :return: AchievementDefinitionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_achievement_with_http_info(name, **kwargs)
        else:
            (data) = self.update_achievement_with_http_info(name, **kwargs)
            return data

    def update_achievement_with_http_info(self, name, **kwargs):
        """
        Update an achievement definition
        The existing generated rule, if any, will be deleted. A new rule will be created if a trigger event name is specified in the new version.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_achievement_with_http_info(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: The name of the achievement (required)
        :param AchievementDefinitionResource achievement: The achievement definition
        :return: AchievementDefinitionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'achievement']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_achievement" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `update_achievement`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'achievement' in params:
            body_params = params['achievement']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/achievements/{name}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AchievementDefinitionResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_achievement_template(self, id, **kwargs):
        """
        Update an achievement template
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_achievement_template(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the template (required)
        :param TemplateResource template: The updated template
        :return: TemplateResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_achievement_template_with_http_info(id, **kwargs)
        else:
            (data) = self.update_achievement_template_with_http_info(id, **kwargs)
            return data

    def update_achievement_template_with_http_info(self, id, **kwargs):
        """
        Update an achievement template
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_achievement_template_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the template (required)
        :param TemplateResource template: The updated template
        :return: TemplateResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'template']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_achievement_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_achievement_template`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'template' in params:
            body_params = params['template']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/achievements/templates/{id}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TemplateResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
