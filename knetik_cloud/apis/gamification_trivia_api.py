# coding: utf-8

"""
    Knetik Platform API Documentation latest 

    This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com.

    OpenAPI spec version: latest 
    Contact: support@knetik.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..api_client import ApiClient


class GamificationTriviaApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_question_answers(self, question_id, **kwargs):
        """
        Add an answer to a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_question_answers(question_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str question_id: The id of the question (required)
        :param AnswerResource answer: The new answer
        :return: AnswerResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_question_answers_with_http_info(question_id, **kwargs)
        else:
            (data) = self.add_question_answers_with_http_info(question_id, **kwargs)
            return data

    def add_question_answers_with_http_info(self, question_id, **kwargs):
        """
        Add an answer to a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_question_answers_with_http_info(question_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str question_id: The id of the question (required)
        :param AnswerResource answer: The new answer
        :return: AnswerResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['question_id', 'answer']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_question_answers" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'question_id' is set
        if ('question_id' not in params) or (params['question_id'] is None):
            raise ValueError("Missing the required parameter `question_id` when calling `add_question_answers`")


        collection_formats = {}

        path_params = {}
        if 'question_id' in params:
            path_params['question_id'] = params['question_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'answer' in params:
            body_params = params['answer']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/questions/{question_id}/answers', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AnswerResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def add_question_tag(self, id, **kwargs):
        """
        Add a tag to a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_question_tag(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the question (required)
        :param StringWrapper tag: The new tag
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_question_tag_with_http_info(id, **kwargs)
        else:
            (data) = self.add_question_tag_with_http_info(id, **kwargs)
            return data

    def add_question_tag_with_http_info(self, id, **kwargs):
        """
        Add a tag to a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_question_tag_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the question (required)
        :param StringWrapper tag: The new tag
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'tag']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_question_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `add_question_tag`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tag' in params:
            body_params = params['tag']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/questions/{id}/tags', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def add_tag_to_questions_batch(self, **kwargs):
        """
        Add a tag to a batch of questions
        All questions that dont't have the tag and match filters will have it added. The returned number is the number of questions updated.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_tag_to_questions_batch(async=True)
        >>> result = thread.get()

        :param async bool
        :param StringWrapper tag: The tag to add
        :param str filter_search: Filter for documents whose question, answers or tags contains provided string
        :param str filter_idset: Filter for documents whose id is in the comma separated list provided
        :param str filter_category: Filter for questions with specified category, by id
        :param str filter_tag: Filter for questions with specified tag
        :param str filter_tagset: Filter for questions with specified tags (separated by comma)
        :param str filter_type: Filter for questions with specified type
        :param bool filter_published: Filter for questions currenctly published or not
        :param int filter_import_id: Filter for questions from a specific import job
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_tag_to_questions_batch_with_http_info(**kwargs)
        else:
            (data) = self.add_tag_to_questions_batch_with_http_info(**kwargs)
            return data

    def add_tag_to_questions_batch_with_http_info(self, **kwargs):
        """
        Add a tag to a batch of questions
        All questions that dont't have the tag and match filters will have it added. The returned number is the number of questions updated.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_tag_to_questions_batch_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param StringWrapper tag: The tag to add
        :param str filter_search: Filter for documents whose question, answers or tags contains provided string
        :param str filter_idset: Filter for documents whose id is in the comma separated list provided
        :param str filter_category: Filter for questions with specified category, by id
        :param str filter_tag: Filter for questions with specified tag
        :param str filter_tagset: Filter for questions with specified tags (separated by comma)
        :param str filter_type: Filter for questions with specified type
        :param bool filter_published: Filter for questions currenctly published or not
        :param int filter_import_id: Filter for questions from a specific import job
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tag', 'filter_search', 'filter_idset', 'filter_category', 'filter_tag', 'filter_tagset', 'filter_type', 'filter_published', 'filter_import_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_tag_to_questions_batch" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter_search' in params:
            query_params.append(('filter_search', params['filter_search']))
        if 'filter_idset' in params:
            query_params.append(('filter_idset', params['filter_idset']))
        if 'filter_category' in params:
            query_params.append(('filter_category', params['filter_category']))
        if 'filter_tag' in params:
            query_params.append(('filter_tag', params['filter_tag']))
        if 'filter_tagset' in params:
            query_params.append(('filter_tagset', params['filter_tagset']))
        if 'filter_type' in params:
            query_params.append(('filter_type', params['filter_type']))
        if 'filter_published' in params:
            query_params.append(('filter_published', params['filter_published']))
        if 'filter_import_id' in params:
            query_params.append(('filter_import_id', params['filter_import_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tag' in params:
            body_params = params['tag']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/questions/tags', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='int',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_import_job(self, **kwargs):
        """
        Create an import job
        Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_import_job(async=True)
        >>> result = thread.get()

        :param async bool
        :param ImportJobResource request: The new import job
        :return: ImportJobResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_import_job_with_http_info(**kwargs)
        else:
            (data) = self.create_import_job_with_http_info(**kwargs)
            return data

    def create_import_job_with_http_info(self, **kwargs):
        """
        Create an import job
        Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_import_job_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param ImportJobResource request: The new import job
        :return: ImportJobResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['request']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_import_job" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request' in params:
            body_params = params['request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/import', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ImportJobResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_question(self, **kwargs):
        """
        Create a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_question(async=True)
        >>> result = thread.get()

        :param async bool
        :param QuestionResource question: The new question
        :return: QuestionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_question_with_http_info(**kwargs)
        else:
            (data) = self.create_question_with_http_info(**kwargs)
            return data

    def create_question_with_http_info(self, **kwargs):
        """
        Create a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_question_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param QuestionResource question: The new question
        :return: QuestionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['question']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_question" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'question' in params:
            body_params = params['question']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/questions', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='QuestionResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_question_template(self, **kwargs):
        """
        Create a question template
        Question templates define a type of question and the properties they have
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_question_template(async=True)
        >>> result = thread.get()

        :param async bool
        :param QuestionTemplateResource question_template_resource: The question template resource object
        :return: QuestionTemplateResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_question_template_with_http_info(**kwargs)
        else:
            (data) = self.create_question_template_with_http_info(**kwargs)
            return data

    def create_question_template_with_http_info(self, **kwargs):
        """
        Create a question template
        Question templates define a type of question and the properties they have
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_question_template_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param QuestionTemplateResource question_template_resource: The question template resource object
        :return: QuestionTemplateResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['question_template_resource']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_question_template" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'question_template_resource' in params:
            body_params = params['question_template_resource']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/questions/templates', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='QuestionTemplateResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_import_job(self, id, **kwargs):
        """
        Delete an import job
        Also deletes all questions that were imported by it
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_import_job(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the job (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_import_job_with_http_info(id, **kwargs)
        else:
            (data) = self.delete_import_job_with_http_info(id, **kwargs)
            return data

    def delete_import_job_with_http_info(self, id, **kwargs):
        """
        Delete an import job
        Also deletes all questions that were imported by it
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_import_job_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the job (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_import_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_import_job`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/import/{id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_question(self, id, **kwargs):
        """
        Delete a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_question(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the question (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_question_with_http_info(id, **kwargs)
        else:
            (data) = self.delete_question_with_http_info(id, **kwargs)
            return data

    def delete_question_with_http_info(self, id, **kwargs):
        """
        Delete a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_question_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the question (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_question" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_question`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/questions/{id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_question_answers(self, question_id, id, **kwargs):
        """
        Remove an answer from a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_question_answers(question_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str question_id: The id of the question (required)
        :param str id: The id of the answer (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_question_answers_with_http_info(question_id, id, **kwargs)
        else:
            (data) = self.delete_question_answers_with_http_info(question_id, id, **kwargs)
            return data

    def delete_question_answers_with_http_info(self, question_id, id, **kwargs):
        """
        Remove an answer from a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_question_answers_with_http_info(question_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str question_id: The id of the question (required)
        :param str id: The id of the answer (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['question_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_question_answers" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'question_id' is set
        if ('question_id' not in params) or (params['question_id'] is None):
            raise ValueError("Missing the required parameter `question_id` when calling `delete_question_answers`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_question_answers`")


        collection_formats = {}

        path_params = {}
        if 'question_id' in params:
            path_params['question_id'] = params['question_id']
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/questions/{question_id}/answers/{id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_question_template(self, id, **kwargs):
        """
        Delete a question template
        If cascade = 'detach', it will force delete the template even if it's attached to other objects
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_question_template(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the template (required)
        :param str cascade: The value needed to delete used templates
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_question_template_with_http_info(id, **kwargs)
        else:
            (data) = self.delete_question_template_with_http_info(id, **kwargs)
            return data

    def delete_question_template_with_http_info(self, id, **kwargs):
        """
        Delete a question template
        If cascade = 'detach', it will force delete the template even if it's attached to other objects
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_question_template_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the template (required)
        :param str cascade: The value needed to delete used templates
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'cascade']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_question_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_question_template`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'cascade' in params:
            query_params.append(('cascade', params['cascade']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/questions/templates/{id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_import_job(self, id, **kwargs):
        """
        Get an import job
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_import_job(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the job (required)
        :return: ImportJobResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_import_job_with_http_info(id, **kwargs)
        else:
            (data) = self.get_import_job_with_http_info(id, **kwargs)
            return data

    def get_import_job_with_http_info(self, id, **kwargs):
        """
        Get an import job
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_import_job_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the job (required)
        :return: ImportJobResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_import_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_import_job`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/import/{id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ImportJobResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_import_jobs(self, **kwargs):
        """
        Get a list of import job
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_import_jobs(async=True)
        >>> result = thread.get()

        :param async bool
        :param str filter_vendor: Filter for jobs by vendor id
        :param str filter_category: Filter for jobs by category id
        :param str filter_name: Filter for jobs which name *STARTS* with the given string
        :param str filter_status: Filter for jobs that are in a specific set of statuses (comma separated)
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :param str order: A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
        :return: PageResourceImportJobResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_import_jobs_with_http_info(**kwargs)
        else:
            (data) = self.get_import_jobs_with_http_info(**kwargs)
            return data

    def get_import_jobs_with_http_info(self, **kwargs):
        """
        Get a list of import job
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_import_jobs_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str filter_vendor: Filter for jobs by vendor id
        :param str filter_category: Filter for jobs by category id
        :param str filter_name: Filter for jobs which name *STARTS* with the given string
        :param str filter_status: Filter for jobs that are in a specific set of statuses (comma separated)
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :param str order: A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
        :return: PageResourceImportJobResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter_vendor', 'filter_category', 'filter_name', 'filter_status', 'size', 'page', 'order']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_import_jobs" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter_vendor' in params:
            query_params.append(('filter_vendor', params['filter_vendor']))
        if 'filter_category' in params:
            query_params.append(('filter_category', params['filter_category']))
        if 'filter_name' in params:
            query_params.append(('filter_name', params['filter_name']))
        if 'filter_status' in params:
            query_params.append(('filter_status', params['filter_status']))
        if 'size' in params:
            query_params.append(('size', params['size']))
        if 'page' in params:
            query_params.append(('page', params['page']))
        if 'order' in params:
            query_params.append(('order', params['order']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/import', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PageResourceImportJobResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_question(self, id, **kwargs):
        """
        Get a single question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_question(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the question (required)
        :return: QuestionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_question_with_http_info(id, **kwargs)
        else:
            (data) = self.get_question_with_http_info(id, **kwargs)
            return data

    def get_question_with_http_info(self, id, **kwargs):
        """
        Get a single question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_question_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the question (required)
        :return: QuestionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_question" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_question`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/questions/{id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='QuestionResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_question_answer(self, question_id, id, **kwargs):
        """
        Get an answer for a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_question_answer(question_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str question_id: The id of the question (required)
        :param str id: The id of the answer (required)
        :return: AnswerResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_question_answer_with_http_info(question_id, id, **kwargs)
        else:
            (data) = self.get_question_answer_with_http_info(question_id, id, **kwargs)
            return data

    def get_question_answer_with_http_info(self, question_id, id, **kwargs):
        """
        Get an answer for a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_question_answer_with_http_info(question_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str question_id: The id of the question (required)
        :param str id: The id of the answer (required)
        :return: AnswerResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['question_id', 'id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_question_answer" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'question_id' is set
        if ('question_id' not in params) or (params['question_id'] is None):
            raise ValueError("Missing the required parameter `question_id` when calling `get_question_answer`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_question_answer`")


        collection_formats = {}

        path_params = {}
        if 'question_id' in params:
            path_params['question_id'] = params['question_id']
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/questions/{question_id}/answers/{id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AnswerResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_question_answers(self, question_id, **kwargs):
        """
        List the answers available for a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_question_answers(question_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str question_id: The id of the question (required)
        :return: list[AnswerResource]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_question_answers_with_http_info(question_id, **kwargs)
        else:
            (data) = self.get_question_answers_with_http_info(question_id, **kwargs)
            return data

    def get_question_answers_with_http_info(self, question_id, **kwargs):
        """
        List the answers available for a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_question_answers_with_http_info(question_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str question_id: The id of the question (required)
        :return: list[AnswerResource]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['question_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_question_answers" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'question_id' is set
        if ('question_id' not in params) or (params['question_id'] is None):
            raise ValueError("Missing the required parameter `question_id` when calling `get_question_answers`")


        collection_formats = {}

        path_params = {}
        if 'question_id' in params:
            path_params['question_id'] = params['question_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/questions/{question_id}/answers', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[AnswerResource]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_question_deltas(self, **kwargs):
        """
        List question deltas in ascending order of updated date
        The 'since' parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_question_deltas(async=True)
        >>> result = thread.get()

        :param async bool
        :param int since: Timestamp in seconds
        :return: list[DeltaResource]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_question_deltas_with_http_info(**kwargs)
        else:
            (data) = self.get_question_deltas_with_http_info(**kwargs)
            return data

    def get_question_deltas_with_http_info(self, **kwargs):
        """
        List question deltas in ascending order of updated date
        The 'since' parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_question_deltas_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int since: Timestamp in seconds
        :return: list[DeltaResource]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['since']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_question_deltas" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'since' in params:
            query_params.append(('since', params['since']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/questions/delta', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[DeltaResource]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_question_tags(self, id, **kwargs):
        """
        List the tags for a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_question_tags(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the question (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_question_tags_with_http_info(id, **kwargs)
        else:
            (data) = self.get_question_tags_with_http_info(id, **kwargs)
            return data

    def get_question_tags_with_http_info(self, id, **kwargs):
        """
        List the tags for a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_question_tags_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the question (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_question_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_question_tags`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/questions/{id}/tags', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[str]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_question_template(self, id, **kwargs):
        """
        Get a single question template
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_question_template(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the template (required)
        :return: QuestionTemplateResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_question_template_with_http_info(id, **kwargs)
        else:
            (data) = self.get_question_template_with_http_info(id, **kwargs)
            return data

    def get_question_template_with_http_info(self, id, **kwargs):
        """
        Get a single question template
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_question_template_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the template (required)
        :return: QuestionTemplateResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_question_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_question_template`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/questions/templates/{id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='QuestionTemplateResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_question_templates(self, **kwargs):
        """
        List and search question templates
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_question_templates(async=True)
        >>> result = thread.get()

        :param async bool
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :param str order: A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
        :return: PageResourceQuestionTemplateResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_question_templates_with_http_info(**kwargs)
        else:
            (data) = self.get_question_templates_with_http_info(**kwargs)
            return data

    def get_question_templates_with_http_info(self, **kwargs):
        """
        List and search question templates
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_question_templates_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :param str order: A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
        :return: PageResourceQuestionTemplateResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['size', 'page', 'order']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_question_templates" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'size' in params:
            query_params.append(('size', params['size']))
        if 'page' in params:
            query_params.append(('page', params['page']))
        if 'order' in params:
            query_params.append(('order', params['order']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/questions/templates', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PageResourceQuestionTemplateResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_questions(self, **kwargs):
        """
        List and search questions
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_questions(async=True)
        >>> result = thread.get()

        :param async bool
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :param str order: A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
        :param str filter_search: Filter for documents whose question, answers or tags contains provided string
        :param str filter_idset: Filter for documents whose id is in the comma separated list provided
        :param str filter_category: Filter for questions with specified category, by id
        :param str filter_tagset: Filter for questions with specified tags (separated by comma)
        :param str filter_tag: Filter for questions with specified tag
        :param str filter_type: Filter for questions with specified type.  Allowable values: ('TEXT', 'IMAGE', 'VIDEO', 'AUDIO')
        :param bool filter_published: Filter for questions currenctly published or not
        :param int filter_import_id: Filter for questions from a specific import job
        :return: PageResourceQuestionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_questions_with_http_info(**kwargs)
        else:
            (data) = self.get_questions_with_http_info(**kwargs)
            return data

    def get_questions_with_http_info(self, **kwargs):
        """
        List and search questions
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_questions_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :param str order: A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
        :param str filter_search: Filter for documents whose question, answers or tags contains provided string
        :param str filter_idset: Filter for documents whose id is in the comma separated list provided
        :param str filter_category: Filter for questions with specified category, by id
        :param str filter_tagset: Filter for questions with specified tags (separated by comma)
        :param str filter_tag: Filter for questions with specified tag
        :param str filter_type: Filter for questions with specified type.  Allowable values: ('TEXT', 'IMAGE', 'VIDEO', 'AUDIO')
        :param bool filter_published: Filter for questions currenctly published or not
        :param int filter_import_id: Filter for questions from a specific import job
        :return: PageResourceQuestionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['size', 'page', 'order', 'filter_search', 'filter_idset', 'filter_category', 'filter_tagset', 'filter_tag', 'filter_type', 'filter_published', 'filter_import_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_questions" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'size' in params:
            query_params.append(('size', params['size']))
        if 'page' in params:
            query_params.append(('page', params['page']))
        if 'order' in params:
            query_params.append(('order', params['order']))
        if 'filter_search' in params:
            query_params.append(('filter_search', params['filter_search']))
        if 'filter_idset' in params:
            query_params.append(('filter_idset', params['filter_idset']))
        if 'filter_category' in params:
            query_params.append(('filter_category', params['filter_category']))
        if 'filter_tagset' in params:
            query_params.append(('filter_tagset', params['filter_tagset']))
        if 'filter_tag' in params:
            query_params.append(('filter_tag', params['filter_tag']))
        if 'filter_type' in params:
            query_params.append(('filter_type', params['filter_type']))
        if 'filter_published' in params:
            query_params.append(('filter_published', params['filter_published']))
        if 'filter_import_id' in params:
            query_params.append(('filter_import_id', params['filter_import_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/questions', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PageResourceQuestionResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_questions_count(self, **kwargs):
        """
        Count questions based on filters
        This is also provided by the list endpoint so you don't need to call this for pagination purposes
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_questions_count(async=True)
        >>> result = thread.get()

        :param async bool
        :param str filter_search: Filter for documents whose question, answers or tags contains provided string
        :param str filter_idset: Filter for documents whose id is in the comma separated list provided
        :param str filter_category: Filter for questions with specified category, by id
        :param str filter_tag: Filter for questions with specified tag
        :param str filter_tagset: Filter for questions with specified tags (separated by comma)
        :param str filter_type: Filter for questions with specified type.  Allowable values: ('TEXT', 'IMAGE', 'VIDEO', 'AUDIO')
        :param bool filter_published: Filter for questions currenctly published or not
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_questions_count_with_http_info(**kwargs)
        else:
            (data) = self.get_questions_count_with_http_info(**kwargs)
            return data

    def get_questions_count_with_http_info(self, **kwargs):
        """
        Count questions based on filters
        This is also provided by the list endpoint so you don't need to call this for pagination purposes
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_questions_count_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str filter_search: Filter for documents whose question, answers or tags contains provided string
        :param str filter_idset: Filter for documents whose id is in the comma separated list provided
        :param str filter_category: Filter for questions with specified category, by id
        :param str filter_tag: Filter for questions with specified tag
        :param str filter_tagset: Filter for questions with specified tags (separated by comma)
        :param str filter_type: Filter for questions with specified type.  Allowable values: ('TEXT', 'IMAGE', 'VIDEO', 'AUDIO')
        :param bool filter_published: Filter for questions currenctly published or not
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter_search', 'filter_idset', 'filter_category', 'filter_tag', 'filter_tagset', 'filter_type', 'filter_published']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_questions_count" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter_search' in params:
            query_params.append(('filter_search', params['filter_search']))
        if 'filter_idset' in params:
            query_params.append(('filter_idset', params['filter_idset']))
        if 'filter_category' in params:
            query_params.append(('filter_category', params['filter_category']))
        if 'filter_tag' in params:
            query_params.append(('filter_tag', params['filter_tag']))
        if 'filter_tagset' in params:
            query_params.append(('filter_tagset', params['filter_tagset']))
        if 'filter_type' in params:
            query_params.append(('filter_type', params['filter_type']))
        if 'filter_published' in params:
            query_params.append(('filter_published', params['filter_published']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/questions/count', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='int',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def process_import_job(self, id, publish_now, **kwargs):
        """
        Start processing an import job
        Will process the CSV file and add new questions asynchronously. The status of the job must be 'VALID'.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.process_import_job(id, publish_now, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the job (required)
        :param bool publish_now: Whether the new questions should be published live immediately (required)
        :return: ImportJobResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.process_import_job_with_http_info(id, publish_now, **kwargs)
        else:
            (data) = self.process_import_job_with_http_info(id, publish_now, **kwargs)
            return data

    def process_import_job_with_http_info(self, id, publish_now, **kwargs):
        """
        Start processing an import job
        Will process the CSV file and add new questions asynchronously. The status of the job must be 'VALID'.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.process_import_job_with_http_info(id, publish_now, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the job (required)
        :param bool publish_now: Whether the new questions should be published live immediately (required)
        :return: ImportJobResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'publish_now']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method process_import_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `process_import_job`")
        # verify the required parameter 'publish_now' is set
        if ('publish_now' not in params) or (params['publish_now'] is None):
            raise ValueError("Missing the required parameter `publish_now` when calling `process_import_job`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'publish_now' in params:
            query_params.append(('publish_now', params['publish_now']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/import/{id}/process', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ImportJobResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def remove_question_tag(self, id, tag, **kwargs):
        """
        Remove a tag from a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remove_question_tag(id, tag, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the question (required)
        :param str tag: The tag to remove (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remove_question_tag_with_http_info(id, tag, **kwargs)
        else:
            (data) = self.remove_question_tag_with_http_info(id, tag, **kwargs)
            return data

    def remove_question_tag_with_http_info(self, id, tag, **kwargs):
        """
        Remove a tag from a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remove_question_tag_with_http_info(id, tag, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the question (required)
        :param str tag: The tag to remove (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'tag']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_question_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `remove_question_tag`")
        # verify the required parameter 'tag' is set
        if ('tag' not in params) or (params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `remove_question_tag`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']
        if 'tag' in params:
            path_params['tag'] = params['tag']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/questions/{id}/tags/{tag}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def remove_tag_to_questions_batch(self, tag, **kwargs):
        """
        Remove a tag from a batch of questions
        ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remove_tag_to_questions_batch(tag, async=True)
        >>> result = thread.get()

        :param async bool
        :param str tag: The tag to remove (required)
        :param str filter_search: Filter for documents whose question, answers or tags contains provided string
        :param str filter_idset: Filter for documents whose id is in the comma separated list provided
        :param str filter_category: Filter for questions with specified category, by id
        :param str filter_tag: Filter for questions with specified tag
        :param str filter_tagset: Filter for questions with specified tags (separated by comma)
        :param str filter_type: Filter for questions with specified type.  Allowable values: ('TEXT', 'IMAGE', 'VIDEO', 'AUDIO')
        :param bool filter_published: Filter for questions currenctly published or not
        :param int filter_import_id: Filter for questions from a specific import job
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remove_tag_to_questions_batch_with_http_info(tag, **kwargs)
        else:
            (data) = self.remove_tag_to_questions_batch_with_http_info(tag, **kwargs)
            return data

    def remove_tag_to_questions_batch_with_http_info(self, tag, **kwargs):
        """
        Remove a tag from a batch of questions
        ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remove_tag_to_questions_batch_with_http_info(tag, async=True)
        >>> result = thread.get()

        :param async bool
        :param str tag: The tag to remove (required)
        :param str filter_search: Filter for documents whose question, answers or tags contains provided string
        :param str filter_idset: Filter for documents whose id is in the comma separated list provided
        :param str filter_category: Filter for questions with specified category, by id
        :param str filter_tag: Filter for questions with specified tag
        :param str filter_tagset: Filter for questions with specified tags (separated by comma)
        :param str filter_type: Filter for questions with specified type.  Allowable values: ('TEXT', 'IMAGE', 'VIDEO', 'AUDIO')
        :param bool filter_published: Filter for questions currenctly published or not
        :param int filter_import_id: Filter for questions from a specific import job
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tag', 'filter_search', 'filter_idset', 'filter_category', 'filter_tag', 'filter_tagset', 'filter_type', 'filter_published', 'filter_import_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_tag_to_questions_batch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tag' is set
        if ('tag' not in params) or (params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `remove_tag_to_questions_batch`")


        collection_formats = {}

        path_params = {}
        if 'tag' in params:
            path_params['tag'] = params['tag']

        query_params = []
        if 'filter_search' in params:
            query_params.append(('filter_search', params['filter_search']))
        if 'filter_idset' in params:
            query_params.append(('filter_idset', params['filter_idset']))
        if 'filter_category' in params:
            query_params.append(('filter_category', params['filter_category']))
        if 'filter_tag' in params:
            query_params.append(('filter_tag', params['filter_tag']))
        if 'filter_tagset' in params:
            query_params.append(('filter_tagset', params['filter_tagset']))
        if 'filter_type' in params:
            query_params.append(('filter_type', params['filter_type']))
        if 'filter_published' in params:
            query_params.append(('filter_published', params['filter_published']))
        if 'filter_import_id' in params:
            query_params.append(('filter_import_id', params['filter_import_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/questions/tags/{tag}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='int',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def search_question_tags(self, **kwargs):
        """
        List and search tags by the beginning of the string
        For performance reasons, search & category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_question_tags(async=True)
        >>> result = thread.get()

        :param async bool
        :param str filter_search: Filter for tags starting with the given text
        :param str filter_category: Filter for tags on questions from a specific category
        :param int filter_import_id: Filter for tags on questions from a specific import job
        :return: Collectionstring
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_question_tags_with_http_info(**kwargs)
        else:
            (data) = self.search_question_tags_with_http_info(**kwargs)
            return data

    def search_question_tags_with_http_info(self, **kwargs):
        """
        List and search tags by the beginning of the string
        For performance reasons, search & category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_question_tags_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str filter_search: Filter for tags starting with the given text
        :param str filter_category: Filter for tags on questions from a specific category
        :param int filter_import_id: Filter for tags on questions from a specific import job
        :return: Collectionstring
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter_search', 'filter_category', 'filter_import_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_question_tags" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter_search' in params:
            query_params.append(('filter_search', params['filter_search']))
        if 'filter_category' in params:
            query_params.append(('filter_category', params['filter_category']))
        if 'filter_import_id' in params:
            query_params.append(('filter_import_id', params['filter_import_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/tags', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Collectionstring',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_import_job(self, id, **kwargs):
        """
        Update an import job
        Changes should be made before process is started for there to be any effect.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_import_job(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the job (required)
        :param ImportJobResource request: The updated job
        :return: ImportJobResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_import_job_with_http_info(id, **kwargs)
        else:
            (data) = self.update_import_job_with_http_info(id, **kwargs)
            return data

    def update_import_job_with_http_info(self, id, **kwargs):
        """
        Update an import job
        Changes should be made before process is started for there to be any effect.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_import_job_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the job (required)
        :param ImportJobResource request: The updated job
        :return: ImportJobResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'request']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_import_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_import_job`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request' in params:
            body_params = params['request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/import/{id}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ImportJobResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_question(self, id, **kwargs):
        """
        Update a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_question(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the question (required)
        :param QuestionResource question: The updated question
        :return: QuestionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_question_with_http_info(id, **kwargs)
        else:
            (data) = self.update_question_with_http_info(id, **kwargs)
            return data

    def update_question_with_http_info(self, id, **kwargs):
        """
        Update a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_question_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the question (required)
        :param QuestionResource question: The updated question
        :return: QuestionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'question']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_question" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_question`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'question' in params:
            body_params = params['question']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/questions/{id}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='QuestionResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_question_answer(self, question_id, id, **kwargs):
        """
        Update an answer for a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_question_answer(question_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str question_id: The id of the question (required)
        :param str id: The id of the answer (required)
        :param AnswerResource answer: The updated answer
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_question_answer_with_http_info(question_id, id, **kwargs)
        else:
            (data) = self.update_question_answer_with_http_info(question_id, id, **kwargs)
            return data

    def update_question_answer_with_http_info(self, question_id, id, **kwargs):
        """
        Update an answer for a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_question_answer_with_http_info(question_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str question_id: The id of the question (required)
        :param str id: The id of the answer (required)
        :param AnswerResource answer: The updated answer
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['question_id', 'id', 'answer']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_question_answer" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'question_id' is set
        if ('question_id' not in params) or (params['question_id'] is None):
            raise ValueError("Missing the required parameter `question_id` when calling `update_question_answer`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_question_answer`")


        collection_formats = {}

        path_params = {}
        if 'question_id' in params:
            path_params['question_id'] = params['question_id']
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'answer' in params:
            body_params = params['answer']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/questions/{question_id}/answers/{id}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_question_template(self, id, **kwargs):
        """
        Update a question template
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_question_template(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the template (required)
        :param QuestionTemplateResource question_template_resource: The question template resource object
        :return: QuestionTemplateResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_question_template_with_http_info(id, **kwargs)
        else:
            (data) = self.update_question_template_with_http_info(id, **kwargs)
            return data

    def update_question_template_with_http_info(self, id, **kwargs):
        """
        Update a question template
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_question_template_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The id of the template (required)
        :param QuestionTemplateResource question_template_resource: The question template resource object
        :return: QuestionTemplateResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'question_template_resource']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_question_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_question_template`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'question_template_resource' in params:
            body_params = params['question_template_resource']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/questions/templates/{id}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='QuestionTemplateResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_questions_in_bulk(self, **kwargs):
        """
        Bulk update questions
        Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_questions_in_bulk(async=True)
        >>> result = thread.get()

        :param async bool
        :param QuestionResource question: New values for a set of question fields
        :param str filter_search: Filter for documents whose question, answers or tags contains provided string
        :param str filter_idset: Filter for documents whose id is in the comma separated list provided
        :param str filter_category: Filter for questions with specified category, by id
        :param str filter_tagset: Filter for questions with specified tags (separated by comma)
        :param str filter_type: Filter for questions with specified type.  Allowable values: ('TEXT', 'IMAGE', 'VIDEO', 'AUDIO')
        :param bool filter_published: Filter for questions currenctly published or not
        :param int filter_import_id: Filter for questions from a specific import job
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_questions_in_bulk_with_http_info(**kwargs)
        else:
            (data) = self.update_questions_in_bulk_with_http_info(**kwargs)
            return data

    def update_questions_in_bulk_with_http_info(self, **kwargs):
        """
        Bulk update questions
        Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_questions_in_bulk_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param QuestionResource question: New values for a set of question fields
        :param str filter_search: Filter for documents whose question, answers or tags contains provided string
        :param str filter_idset: Filter for documents whose id is in the comma separated list provided
        :param str filter_category: Filter for questions with specified category, by id
        :param str filter_tagset: Filter for questions with specified tags (separated by comma)
        :param str filter_type: Filter for questions with specified type.  Allowable values: ('TEXT', 'IMAGE', 'VIDEO', 'AUDIO')
        :param bool filter_published: Filter for questions currenctly published or not
        :param int filter_import_id: Filter for questions from a specific import job
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['question', 'filter_search', 'filter_idset', 'filter_category', 'filter_tagset', 'filter_type', 'filter_published', 'filter_import_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_questions_in_bulk" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter_search' in params:
            query_params.append(('filter_search', params['filter_search']))
        if 'filter_idset' in params:
            query_params.append(('filter_idset', params['filter_idset']))
        if 'filter_category' in params:
            query_params.append(('filter_category', params['filter_category']))
        if 'filter_tagset' in params:
            query_params.append(('filter_tagset', params['filter_tagset']))
        if 'filter_type' in params:
            query_params.append(('filter_type', params['filter_type']))
        if 'filter_published' in params:
            query_params.append(('filter_published', params['filter_published']))
        if 'filter_import_id' in params:
            query_params.append(('filter_import_id', params['filter_import_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'question' in params:
            body_params = params['question']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['oauth2_client_credentials_grant', 'oauth2_password_grant']

        return self.api_client.call_api('/trivia/questions', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='int',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
