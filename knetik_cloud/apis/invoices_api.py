# coding: utf-8

"""
    Knetik Platform API Documentation latest 

    This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com.

    OpenAPI spec version: latest 
    Contact: support@knetik.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..api_client import ApiClient


class InvoicesApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_invoice(self, **kwargs):
        """
        Create an invoice
        Create an invoice(s) by providing a cart GUID. Note that there may be multiple invoices created, one per vendor.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_invoice(async=True)
        >>> result = thread.get()

        :param async bool
        :param InvoiceCreateRequest req: Invoice to be created
        :return: list[InvoiceResource]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_invoice_with_http_info(**kwargs)
        else:
            (data) = self.create_invoice_with_http_info(**kwargs)
            return data

    def create_invoice_with_http_info(self, **kwargs):
        """
        Create an invoice
        Create an invoice(s) by providing a cart GUID. Note that there may be multiple invoices created, one per vendor.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_invoice_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param InvoiceCreateRequest req: Invoice to be created
        :return: list[InvoiceResource]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['req']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_invoice" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'req' in params:
            body_params = params['req']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/invoices', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[InvoiceResource]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_ful_fillment_statuses(self, **kwargs):
        """
        Lists available fulfillment statuses
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_ful_fillment_statuses(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_ful_fillment_statuses_with_http_info(**kwargs)
        else:
            (data) = self.get_ful_fillment_statuses_with_http_info(**kwargs)
            return data

    def get_ful_fillment_statuses_with_http_info(self, **kwargs):
        """
        Lists available fulfillment statuses
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_ful_fillment_statuses_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ful_fillment_statuses" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/invoices/fulfillment-statuses', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[str]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_invoice(self, id, **kwargs):
        """
        Retrieve an invoice
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_invoice(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the invoice (required)
        :return: InvoiceResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_invoice_with_http_info(id, **kwargs)
        else:
            (data) = self.get_invoice_with_http_info(id, **kwargs)
            return data

    def get_invoice_with_http_info(self, id, **kwargs):
        """
        Retrieve an invoice
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_invoice_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the invoice (required)
        :return: InvoiceResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invoice" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_invoice`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/invoices/{id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='InvoiceResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_invoice_logs(self, id, **kwargs):
        """
        List invoice logs
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_invoice_logs(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the invoice (required)
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :return: PageResourceInvoiceLogEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_invoice_logs_with_http_info(id, **kwargs)
        else:
            (data) = self.get_invoice_logs_with_http_info(id, **kwargs)
            return data

    def get_invoice_logs_with_http_info(self, id, **kwargs):
        """
        List invoice logs
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_invoice_logs_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the invoice (required)
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :return: PageResourceInvoiceLogEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'size', 'page']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invoice_logs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_invoice_logs`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []
        if 'size' in params:
            query_params.append(('size', params['size']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/invoices/{id}/logs', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PageResourceInvoiceLogEntry',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_invoices(self, **kwargs):
        """
        Retrieve invoices
        Without INVOICES_ADMIN permission the results are automatically filtered for only the logged in user's invoices. It is recomended however that filter_user be added to avoid issues for admin users accidentally getting additional invoices.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_invoices(async=True)
        >>> result = thread.get()

        :param async bool
        :param int filter_user: The id of a user to get invoices for. Automtically added if not being called with admin permissions.
        :param str filter_email: Filters invoices by customer's email. Admins only.
        :param str filter_fulfillment_status: Filters invoices by fulfillment status type. Can be a comma separated list of statuses
        :param str filter_payment_status: Filters invoices by payment status type. Can be a comma separated list of statuses
        :param str filter_item_name: Filters invoices by item name containing the given string
        :param str filter_external_ref: Filters invoices by external reference.
        :param str filter_created_date: Filters invoices by creation date. Multiple values possible for range search. Format: filter_created_date=OP,ts&... where OP in (GT, LT, GOE, LOE, EQ) and ts is a unix timestamp in seconds. Ex: filter_created_date=GT,1452154258,LT,1554254874
        :param str filter_vendor_ids: Filters invoices for ones from one of the vendors whose id is in the given comma separated list
        :param str filter_currency: Filters invoices by currency. ISO3 currency code
        :param str filter_shipping_state_name: Filters invoices by shipping address: Exact match state name
        :param str filter_shipping_country_name: Filters invoices by shipping address: Exact match country name
        :param str filter_shipping: Filters invoices by shipping price. Multiple values possible for range search. Format: filter_shipping=OP,ts&... where OP in (GT, LT, GOE, LOE, EQ). Ex: filter_shipping=GT,14.58,LT,15.54
        :param str filter_vendor_name: Filters invoices by vendor name starting with given string
        :param str filter_sku: Filters invoices by item sku
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :param str order: A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
        :return: PageResourceInvoiceResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_invoices_with_http_info(**kwargs)
        else:
            (data) = self.get_invoices_with_http_info(**kwargs)
            return data

    def get_invoices_with_http_info(self, **kwargs):
        """
        Retrieve invoices
        Without INVOICES_ADMIN permission the results are automatically filtered for only the logged in user's invoices. It is recomended however that filter_user be added to avoid issues for admin users accidentally getting additional invoices.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_invoices_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int filter_user: The id of a user to get invoices for. Automtically added if not being called with admin permissions.
        :param str filter_email: Filters invoices by customer's email. Admins only.
        :param str filter_fulfillment_status: Filters invoices by fulfillment status type. Can be a comma separated list of statuses
        :param str filter_payment_status: Filters invoices by payment status type. Can be a comma separated list of statuses
        :param str filter_item_name: Filters invoices by item name containing the given string
        :param str filter_external_ref: Filters invoices by external reference.
        :param str filter_created_date: Filters invoices by creation date. Multiple values possible for range search. Format: filter_created_date=OP,ts&... where OP in (GT, LT, GOE, LOE, EQ) and ts is a unix timestamp in seconds. Ex: filter_created_date=GT,1452154258,LT,1554254874
        :param str filter_vendor_ids: Filters invoices for ones from one of the vendors whose id is in the given comma separated list
        :param str filter_currency: Filters invoices by currency. ISO3 currency code
        :param str filter_shipping_state_name: Filters invoices by shipping address: Exact match state name
        :param str filter_shipping_country_name: Filters invoices by shipping address: Exact match country name
        :param str filter_shipping: Filters invoices by shipping price. Multiple values possible for range search. Format: filter_shipping=OP,ts&... where OP in (GT, LT, GOE, LOE, EQ). Ex: filter_shipping=GT,14.58,LT,15.54
        :param str filter_vendor_name: Filters invoices by vendor name starting with given string
        :param str filter_sku: Filters invoices by item sku
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :param str order: A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
        :return: PageResourceInvoiceResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter_user', 'filter_email', 'filter_fulfillment_status', 'filter_payment_status', 'filter_item_name', 'filter_external_ref', 'filter_created_date', 'filter_vendor_ids', 'filter_currency', 'filter_shipping_state_name', 'filter_shipping_country_name', 'filter_shipping', 'filter_vendor_name', 'filter_sku', 'size', 'page', 'order']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invoices" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter_user' in params:
            query_params.append(('filter_user', params['filter_user']))
        if 'filter_email' in params:
            query_params.append(('filter_email', params['filter_email']))
        if 'filter_fulfillment_status' in params:
            query_params.append(('filter_fulfillment_status', params['filter_fulfillment_status']))
        if 'filter_payment_status' in params:
            query_params.append(('filter_payment_status', params['filter_payment_status']))
        if 'filter_item_name' in params:
            query_params.append(('filter_item_name', params['filter_item_name']))
        if 'filter_external_ref' in params:
            query_params.append(('filter_external_ref', params['filter_external_ref']))
        if 'filter_created_date' in params:
            query_params.append(('filter_created_date', params['filter_created_date']))
        if 'filter_vendor_ids' in params:
            query_params.append(('filter_vendor_ids', params['filter_vendor_ids']))
        if 'filter_currency' in params:
            query_params.append(('filter_currency', params['filter_currency']))
        if 'filter_shipping_state_name' in params:
            query_params.append(('filter_shipping_state_name', params['filter_shipping_state_name']))
        if 'filter_shipping_country_name' in params:
            query_params.append(('filter_shipping_country_name', params['filter_shipping_country_name']))
        if 'filter_shipping' in params:
            query_params.append(('filter_shipping', params['filter_shipping']))
        if 'filter_vendor_name' in params:
            query_params.append(('filter_vendor_name', params['filter_vendor_name']))
        if 'filter_sku' in params:
            query_params.append(('filter_sku', params['filter_sku']))
        if 'size' in params:
            query_params.append(('size', params['size']))
        if 'page' in params:
            query_params.append(('page', params['page']))
        if 'order' in params:
            query_params.append(('order', params['order']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/invoices', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PageResourceInvoiceResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_payment_statuses(self, **kwargs):
        """
        Lists available payment statuses
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_payment_statuses(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_payment_statuses_with_http_info(**kwargs)
        else:
            (data) = self.get_payment_statuses_with_http_info(**kwargs)
            return data

    def get_payment_statuses_with_http_info(self, **kwargs):
        """
        Lists available payment statuses
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_payment_statuses_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_payment_statuses" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/invoices/payment-statuses', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[str]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def pay_invoice(self, id, **kwargs):
        """
        Pay an invoice using a saved payment method
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.pay_invoice(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the invoice (required)
        :param PayBySavedMethodRequest request: The payment method details. Will default to the appropriate user's wallet in the invoice currency if ommited.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.pay_invoice_with_http_info(id, **kwargs)
        else:
            (data) = self.pay_invoice_with_http_info(id, **kwargs)
            return data

    def pay_invoice_with_http_info(self, id, **kwargs):
        """
        Pay an invoice using a saved payment method
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.pay_invoice_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the invoice (required)
        :param PayBySavedMethodRequest request: The payment method details. Will default to the appropriate user's wallet in the invoice currency if ommited.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'request']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pay_invoice" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `pay_invoice`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request' in params:
            body_params = params['request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/invoices/{id}/payments', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def set_bundled_invoice_item_fulfillment_status(self, id, bundle_sku, sku, status, **kwargs):
        """
        Set the fulfillment status of a bundled invoice item
        This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_bundled_invoice_item_fulfillment_status(id, bundle_sku, sku, status, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the invoice (required)
        :param str bundle_sku: The sku of the bundle in the invoice that contains the given target (required)
        :param str sku: The sku of an item in the bundle in the invoice (required)
        :param StringWrapper status: The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  'unfulfilled', 'fulfilled', 'not fulfillable', 'failed', 'processing', 'failed_permanent', 'delayed' (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.set_bundled_invoice_item_fulfillment_status_with_http_info(id, bundle_sku, sku, status, **kwargs)
        else:
            (data) = self.set_bundled_invoice_item_fulfillment_status_with_http_info(id, bundle_sku, sku, status, **kwargs)
            return data

    def set_bundled_invoice_item_fulfillment_status_with_http_info(self, id, bundle_sku, sku, status, **kwargs):
        """
        Set the fulfillment status of a bundled invoice item
        This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_bundled_invoice_item_fulfillment_status_with_http_info(id, bundle_sku, sku, status, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the invoice (required)
        :param str bundle_sku: The sku of the bundle in the invoice that contains the given target (required)
        :param str sku: The sku of an item in the bundle in the invoice (required)
        :param StringWrapper status: The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  'unfulfilled', 'fulfilled', 'not fulfillable', 'failed', 'processing', 'failed_permanent', 'delayed' (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'bundle_sku', 'sku', 'status']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_bundled_invoice_item_fulfillment_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `set_bundled_invoice_item_fulfillment_status`")
        # verify the required parameter 'bundle_sku' is set
        if ('bundle_sku' not in params) or (params['bundle_sku'] is None):
            raise ValueError("Missing the required parameter `bundle_sku` when calling `set_bundled_invoice_item_fulfillment_status`")
        # verify the required parameter 'sku' is set
        if ('sku' not in params) or (params['sku'] is None):
            raise ValueError("Missing the required parameter `sku` when calling `set_bundled_invoice_item_fulfillment_status`")
        # verify the required parameter 'status' is set
        if ('status' not in params) or (params['status'] is None):
            raise ValueError("Missing the required parameter `status` when calling `set_bundled_invoice_item_fulfillment_status`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']
        if 'bundle_sku' in params:
            path_params['bundleSku'] = params['bundle_sku']
        if 'sku' in params:
            path_params['sku'] = params['sku']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'status' in params:
            body_params = params['status']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/invoices/{id}/items/{bundleSku}/bundled-skus/{sku}/fulfillment-status', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def set_external_ref(self, id, **kwargs):
        """
        Set the external reference of an invoice
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_external_ref(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the invoice (required)
        :param StringWrapper external_ref: External reference info
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.set_external_ref_with_http_info(id, **kwargs)
        else:
            (data) = self.set_external_ref_with_http_info(id, **kwargs)
            return data

    def set_external_ref_with_http_info(self, id, **kwargs):
        """
        Set the external reference of an invoice
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_external_ref_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the invoice (required)
        :param StringWrapper external_ref: External reference info
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'external_ref']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_external_ref" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `set_external_ref`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'external_ref' in params:
            body_params = params['external_ref']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/invoices/{id}/external-ref', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def set_invoice_item_fulfillment_status(self, id, sku, status, **kwargs):
        """
        Set the fulfillment status of an invoice item
        This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_invoice_item_fulfillment_status(id, sku, status, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the invoice (required)
        :param str sku: The sku of an item in the invoice (required)
        :param StringWrapper status: The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  'unfulfilled', 'fulfilled', 'not fulfillable', 'failed', 'processing', 'failed_permanent', 'delayed' (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.set_invoice_item_fulfillment_status_with_http_info(id, sku, status, **kwargs)
        else:
            (data) = self.set_invoice_item_fulfillment_status_with_http_info(id, sku, status, **kwargs)
            return data

    def set_invoice_item_fulfillment_status_with_http_info(self, id, sku, status, **kwargs):
        """
        Set the fulfillment status of an invoice item
        This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_invoice_item_fulfillment_status_with_http_info(id, sku, status, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the invoice (required)
        :param str sku: The sku of an item in the invoice (required)
        :param StringWrapper status: The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  'unfulfilled', 'fulfilled', 'not fulfillable', 'failed', 'processing', 'failed_permanent', 'delayed' (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'sku', 'status']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_invoice_item_fulfillment_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `set_invoice_item_fulfillment_status`")
        # verify the required parameter 'sku' is set
        if ('sku' not in params) or (params['sku'] is None):
            raise ValueError("Missing the required parameter `sku` when calling `set_invoice_item_fulfillment_status`")
        # verify the required parameter 'status' is set
        if ('status' not in params) or (params['status'] is None):
            raise ValueError("Missing the required parameter `status` when calling `set_invoice_item_fulfillment_status`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']
        if 'sku' in params:
            path_params['sku'] = params['sku']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'status' in params:
            body_params = params['status']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/invoices/{id}/items/{sku}/fulfillment-status', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def set_order_notes(self, id, **kwargs):
        """
        Set the order notes of an invoice
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_order_notes(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the invoice (required)
        :param StringWrapper order_notes: Payment status info
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.set_order_notes_with_http_info(id, **kwargs)
        else:
            (data) = self.set_order_notes_with_http_info(id, **kwargs)
            return data

    def set_order_notes_with_http_info(self, id, **kwargs):
        """
        Set the order notes of an invoice
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_order_notes_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the invoice (required)
        :param StringWrapper order_notes: Payment status info
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'order_notes']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_order_notes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `set_order_notes`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'order_notes' in params:
            body_params = params['order_notes']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/invoices/{id}/order-notes', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def set_payment_status(self, id, **kwargs):
        """
        Set the payment status of an invoice
        This may trigger fulfillment if setting the status to 'paid'. This is mainly intended to support external payment systems that cannot be incorporated into the payment method system. Payment status changes are restricted by a specific flow determining which status can lead to which.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_payment_status(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the invoice (required)
        :param InvoicePaymentStatusRequest request: Payment status info
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.set_payment_status_with_http_info(id, **kwargs)
        else:
            (data) = self.set_payment_status_with_http_info(id, **kwargs)
            return data

    def set_payment_status_with_http_info(self, id, **kwargs):
        """
        Set the payment status of an invoice
        This may trigger fulfillment if setting the status to 'paid'. This is mainly intended to support external payment systems that cannot be incorporated into the payment method system. Payment status changes are restricted by a specific flow determining which status can lead to which.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_payment_status_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the invoice (required)
        :param InvoicePaymentStatusRequest request: Payment status info
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'request']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_payment_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `set_payment_status`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request' in params:
            body_params = params['request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/invoices/{id}/payment-status', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_billing_info(self, id, **kwargs):
        """
        Set or update billing info
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_billing_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the invoice (required)
        :param AddressResource billing_info_request: Address info
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_billing_info_with_http_info(id, **kwargs)
        else:
            (data) = self.update_billing_info_with_http_info(id, **kwargs)
            return data

    def update_billing_info_with_http_info(self, id, **kwargs):
        """
        Set or update billing info
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_billing_info_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int id: The id of the invoice (required)
        :param AddressResource billing_info_request: Address info
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'billing_info_request']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_billing_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_billing_info`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'billing_info_request' in params:
            body_params = params['billing_info_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/invoices/{id}/billing-address', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
