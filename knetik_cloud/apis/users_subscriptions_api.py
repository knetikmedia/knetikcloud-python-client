# coding: utf-8

"""
    Knetik Platform API Documentation latest 

    This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com.

    OpenAPI spec version: latest 
    Contact: support@knetik.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..api_client import ApiClient


class UsersSubscriptionsApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def get_user_subscription_details(self, user_id, inventory_id, **kwargs):
        """
        Get details about a user's subscription
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_user_subscription_details(user_id, inventory_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :return: InventorySubscriptionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_user_subscription_details_with_http_info(user_id, inventory_id, **kwargs)
        else:
            (data) = self.get_user_subscription_details_with_http_info(user_id, inventory_id, **kwargs)
            return data

    def get_user_subscription_details_with_http_info(self, user_id, inventory_id, **kwargs):
        """
        Get details about a user's subscription
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_user_subscription_details_with_http_info(user_id, inventory_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :return: InventorySubscriptionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'inventory_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_subscription_details" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `get_user_subscription_details`")
        # verify the required parameter 'inventory_id' is set
        if ('inventory_id' not in params) or (params['inventory_id'] is None):
            raise ValueError("Missing the required parameter `inventory_id` when calling `get_user_subscription_details`")


        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']
        if 'inventory_id' in params:
            path_params['inventory_id'] = params['inventory_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['OAuth2']

        return self.api_client.call_api('/users/{user_id}/subscriptions/{inventory_id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='InventorySubscriptionResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_users_subscription_details(self, user_id, **kwargs):
        """
        Get details about a user's subscriptions
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_users_subscription_details(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The id of the user (required)
        :return: list[InventorySubscriptionResource]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_users_subscription_details_with_http_info(user_id, **kwargs)
        else:
            (data) = self.get_users_subscription_details_with_http_info(user_id, **kwargs)
            return data

    def get_users_subscription_details_with_http_info(self, user_id, **kwargs):
        """
        Get details about a user's subscriptions
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_users_subscription_details_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The id of the user (required)
        :return: list[InventorySubscriptionResource]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_users_subscription_details" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `get_users_subscription_details`")


        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['OAuth2']

        return self.api_client.call_api('/users/{user_id}/subscriptions', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[InventorySubscriptionResource]',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def reactivate_user_subscription(self, user_id, inventory_id, **kwargs):
        """
        Reactivate a subscription and charge fee
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.reactivate_user_subscription(user_id, inventory_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :param ReactivateSubscriptionRequest reactivate_subscription_request: The reactivate subscription request object inventory
        :return: InvoiceResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.reactivate_user_subscription_with_http_info(user_id, inventory_id, **kwargs)
        else:
            (data) = self.reactivate_user_subscription_with_http_info(user_id, inventory_id, **kwargs)
            return data

    def reactivate_user_subscription_with_http_info(self, user_id, inventory_id, **kwargs):
        """
        Reactivate a subscription and charge fee
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.reactivate_user_subscription_with_http_info(user_id, inventory_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :param ReactivateSubscriptionRequest reactivate_subscription_request: The reactivate subscription request object inventory
        :return: InvoiceResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'inventory_id', 'reactivate_subscription_request']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reactivate_user_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `reactivate_user_subscription`")
        # verify the required parameter 'inventory_id' is set
        if ('inventory_id' not in params) or (params['inventory_id'] is None):
            raise ValueError("Missing the required parameter `inventory_id` when calling `reactivate_user_subscription`")


        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']
        if 'inventory_id' in params:
            path_params['inventory_id'] = params['inventory_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'reactivate_subscription_request' in params:
            body_params = params['reactivate_subscription_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['OAuth2']

        return self.api_client.call_api('/users/{user_id}/subscriptions/{inventory_id}/reactivate', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='InvoiceResource',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def set_subscription_bill_date(self, user_id, inventory_id, bill_date, **kwargs):
        """
        Set a new date to bill a subscription on
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_subscription_bill_date(user_id, inventory_id, bill_date, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :param int bill_date: The new bill date. Unix timestamp in seconds (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.set_subscription_bill_date_with_http_info(user_id, inventory_id, bill_date, **kwargs)
        else:
            (data) = self.set_subscription_bill_date_with_http_info(user_id, inventory_id, bill_date, **kwargs)
            return data

    def set_subscription_bill_date_with_http_info(self, user_id, inventory_id, bill_date, **kwargs):
        """
        Set a new date to bill a subscription on
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_subscription_bill_date_with_http_info(user_id, inventory_id, bill_date, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :param int bill_date: The new bill date. Unix timestamp in seconds (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'inventory_id', 'bill_date']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_subscription_bill_date" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `set_subscription_bill_date`")
        # verify the required parameter 'inventory_id' is set
        if ('inventory_id' not in params) or (params['inventory_id'] is None):
            raise ValueError("Missing the required parameter `inventory_id` when calling `set_subscription_bill_date`")
        # verify the required parameter 'bill_date' is set
        if ('bill_date' not in params) or (params['bill_date'] is None):
            raise ValueError("Missing the required parameter `bill_date` when calling `set_subscription_bill_date`")


        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']
        if 'inventory_id' in params:
            path_params['inventory_id'] = params['inventory_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'bill_date' in params:
            body_params = params['bill_date']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['OAuth2']

        return self.api_client.call_api('/users/{user_id}/subscriptions/{inventory_id}/bill-date', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def set_subscription_payment_method(self, user_id, inventory_id, **kwargs):
        """
        Set the payment method to use for a subscription
        May send null to use floating default
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_subscription_payment_method(user_id, inventory_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :param IntWrapper payment_method_id: The id of the payment method
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.set_subscription_payment_method_with_http_info(user_id, inventory_id, **kwargs)
        else:
            (data) = self.set_subscription_payment_method_with_http_info(user_id, inventory_id, **kwargs)
            return data

    def set_subscription_payment_method_with_http_info(self, user_id, inventory_id, **kwargs):
        """
        Set the payment method to use for a subscription
        May send null to use floating default
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_subscription_payment_method_with_http_info(user_id, inventory_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :param IntWrapper payment_method_id: The id of the payment method
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'inventory_id', 'payment_method_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_subscription_payment_method" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `set_subscription_payment_method`")
        # verify the required parameter 'inventory_id' is set
        if ('inventory_id' not in params) or (params['inventory_id'] is None):
            raise ValueError("Missing the required parameter `inventory_id` when calling `set_subscription_payment_method`")


        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']
        if 'inventory_id' in params:
            path_params['inventory_id'] = params['inventory_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payment_method_id' in params:
            body_params = params['payment_method_id']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['OAuth2']

        return self.api_client.call_api('/users/{user_id}/subscriptions/{inventory_id}/payment-method', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def set_subscription_status(self, user_id, inventory_id, status, **kwargs):
        """
        Set the status of a subscription
        Note that the new status may be blocked if the system is not configured to allow the current status to be changed to the new, to enforce proper flow. The default options for statuses are shown below but may be altered for special use cases
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_subscription_status(user_id, inventory_id, status, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :param StringWrapper status: The new status for the subscription. Actual options may differ from the indicated set if the invoice status type data has been altered.  Allowable values: ('current', 'canceled', 'stopped', 'payment_failed', 'suspended') (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.set_subscription_status_with_http_info(user_id, inventory_id, status, **kwargs)
        else:
            (data) = self.set_subscription_status_with_http_info(user_id, inventory_id, status, **kwargs)
            return data

    def set_subscription_status_with_http_info(self, user_id, inventory_id, status, **kwargs):
        """
        Set the status of a subscription
        Note that the new status may be blocked if the system is not configured to allow the current status to be changed to the new, to enforce proper flow. The default options for statuses are shown below but may be altered for special use cases
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_subscription_status_with_http_info(user_id, inventory_id, status, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :param StringWrapper status: The new status for the subscription. Actual options may differ from the indicated set if the invoice status type data has been altered.  Allowable values: ('current', 'canceled', 'stopped', 'payment_failed', 'suspended') (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'inventory_id', 'status']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_subscription_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `set_subscription_status`")
        # verify the required parameter 'inventory_id' is set
        if ('inventory_id' not in params) or (params['inventory_id'] is None):
            raise ValueError("Missing the required parameter `inventory_id` when calling `set_subscription_status`")
        # verify the required parameter 'status' is set
        if ('status' not in params) or (params['status'] is None):
            raise ValueError("Missing the required parameter `status` when calling `set_subscription_status`")


        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']
        if 'inventory_id' in params:
            path_params['inventory_id'] = params['inventory_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'status' in params:
            body_params = params['status']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['OAuth2']

        return self.api_client.call_api('/users/{user_id}/subscriptions/{inventory_id}/status', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def set_user_subscription_plan(self, user_id, inventory_id, **kwargs):
        """
        Set a new subscription plan for a user
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_user_subscription_plan(user_id, inventory_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :param StringWrapper plan_id: The id of the new plan. Must be from the same subscription
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.set_user_subscription_plan_with_http_info(user_id, inventory_id, **kwargs)
        else:
            (data) = self.set_user_subscription_plan_with_http_info(user_id, inventory_id, **kwargs)
            return data

    def set_user_subscription_plan_with_http_info(self, user_id, inventory_id, **kwargs):
        """
        Set a new subscription plan for a user
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_user_subscription_plan_with_http_info(user_id, inventory_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :param StringWrapper plan_id: The id of the new plan. Must be from the same subscription
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'inventory_id', 'plan_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_user_subscription_plan" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `set_user_subscription_plan`")
        # verify the required parameter 'inventory_id' is set
        if ('inventory_id' not in params) or (params['inventory_id'] is None):
            raise ValueError("Missing the required parameter `inventory_id` when calling `set_user_subscription_plan`")


        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']
        if 'inventory_id' in params:
            path_params['inventory_id'] = params['inventory_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'plan_id' in params:
            body_params = params['plan_id']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['OAuth2']

        return self.api_client.call_api('/users/{user_id}/subscriptions/{inventory_id}/plan', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def set_user_subscription_price(self, user_id, inventory_id, **kwargs):
        """
        Set a new subscription price for a user
        This new price will be what the user is charged at the begining of each new period. This override is specific to the current subscription and will not carry over if they end and later re-subscribe. It will persist if the plan is changed using the setUserSubscriptionPlan endpoint.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_user_subscription_price(user_id, inventory_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :param SubscriptionPriceOverrideRequest the_override_details: override
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.set_user_subscription_price_with_http_info(user_id, inventory_id, **kwargs)
        else:
            (data) = self.set_user_subscription_price_with_http_info(user_id, inventory_id, **kwargs)
            return data

    def set_user_subscription_price_with_http_info(self, user_id, inventory_id, **kwargs):
        """
        Set a new subscription price for a user
        This new price will be what the user is charged at the begining of each new period. This override is specific to the current subscription and will not carry over if they end and later re-subscribe. It will persist if the plan is changed using the setUserSubscriptionPlan endpoint.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_user_subscription_price_with_http_info(user_id, inventory_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :param SubscriptionPriceOverrideRequest the_override_details: override
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'inventory_id', 'the_override_details']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_user_subscription_price" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `set_user_subscription_price`")
        # verify the required parameter 'inventory_id' is set
        if ('inventory_id' not in params) or (params['inventory_id'] is None):
            raise ValueError("Missing the required parameter `inventory_id` when calling `set_user_subscription_price`")


        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']
        if 'inventory_id' in params:
            path_params['inventory_id'] = params['inventory_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'the_override_details' in params:
            body_params = params['the_override_details']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['OAuth2']

        return self.api_client.call_api('/users/{user_id}/subscriptions/{inventory_id}/price-override', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
