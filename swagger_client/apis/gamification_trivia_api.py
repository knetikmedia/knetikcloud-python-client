# coding: utf-8

"""
    Knetik Platform API Documentation latest 

    This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://demo.sandbox.knetikcloud.com

    OpenAPI spec version: latest 
    Contact: support@knetik.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class GamificationTriviaApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def add_answers_using_post(self, question_id, **kwargs):
        """
        Add an answer to a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_answers_using_post(question_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str question_id: The id of the question (required)
        :param AnswerResource answer: The new answer
        :return: AnswerResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_answers_using_post_with_http_info(question_id, **kwargs)
        else:
            (data) = self.add_answers_using_post_with_http_info(question_id, **kwargs)
            return data

    def add_answers_using_post_with_http_info(self, question_id, **kwargs):
        """
        Add an answer to a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_answers_using_post_with_http_info(question_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str question_id: The id of the question (required)
        :param AnswerResource answer: The new answer
        :return: AnswerResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['question_id', 'answer']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_answers_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'question_id' is set
        if ('question_id' not in params) or (params['question_id'] is None):
            raise ValueError("Missing the required parameter `question_id` when calling `add_answers_using_post`")


        collection_formats = {}

        resource_path = '/trivia/questions/{question_id}/answers'.replace('{format}', 'json')
        path_params = {}
        if 'question_id' in params:
            path_params['question_id'] = params['question_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'answer' in params:
            body_params = params['answer']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AnswerResource',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def add_tag_using_post(self, id, **kwargs):
        """
        Add a tag to a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_tag_using_post(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The id of the question (required)
        :param str tag: The new tag
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_tag_using_post_with_http_info(id, **kwargs)
        else:
            (data) = self.add_tag_using_post_with_http_info(id, **kwargs)
            return data

    def add_tag_using_post_with_http_info(self, id, **kwargs):
        """
        Add a tag to a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_tag_using_post_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The id of the question (required)
        :param str tag: The new tag
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'tag']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_tag_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `add_tag_using_post`")


        collection_formats = {}

        resource_path = '/trivia/questions/{id}/tags'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tag' in params:
            body_params = params['tag']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def batch_add_tag_using_post(self, **kwargs):
        """
        Add a tag to a batch of questions
        All questions that dont't have the tag and match filters will have it added. The returned number is the number of questions updated.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.batch_add_tag_using_post(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str tag: The tag to add
        :param str filter_search: Filter for documents whose question, answers or tags contains provided string
        :param str filter_idset: Filter for documents whose id is in the comma separated list provided
        :param str filter_category: Filter for questions with specified category, by id
        :param str filter_tag: Filter for questions with specified tag
        :param str filter_tagset: Filter for questions with specified tags (separated by comma)
        :param str filter_type: Filter for questions with specified type
        :param bool filter_published: Filter for questions currenctly published or not
        :param int filter_import_id: Filter for questions from a specific import job
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.batch_add_tag_using_post_with_http_info(**kwargs)
        else:
            (data) = self.batch_add_tag_using_post_with_http_info(**kwargs)
            return data

    def batch_add_tag_using_post_with_http_info(self, **kwargs):
        """
        Add a tag to a batch of questions
        All questions that dont't have the tag and match filters will have it added. The returned number is the number of questions updated.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.batch_add_tag_using_post_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str tag: The tag to add
        :param str filter_search: Filter for documents whose question, answers or tags contains provided string
        :param str filter_idset: Filter for documents whose id is in the comma separated list provided
        :param str filter_category: Filter for questions with specified category, by id
        :param str filter_tag: Filter for questions with specified tag
        :param str filter_tagset: Filter for questions with specified tags (separated by comma)
        :param str filter_type: Filter for questions with specified type
        :param bool filter_published: Filter for questions currenctly published or not
        :param int filter_import_id: Filter for questions from a specific import job
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tag', 'filter_search', 'filter_idset', 'filter_category', 'filter_tag', 'filter_tagset', 'filter_type', 'filter_published', 'filter_import_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method batch_add_tag_using_post" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/trivia/questions/tags'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'filter_search' in params:
            query_params['filter_search'] = params['filter_search']
        if 'filter_idset' in params:
            query_params['filter_idset'] = params['filter_idset']
        if 'filter_category' in params:
            query_params['filter_category'] = params['filter_category']
        if 'filter_tag' in params:
            query_params['filter_tag'] = params['filter_tag']
        if 'filter_tagset' in params:
            query_params['filter_tagset'] = params['filter_tagset']
        if 'filter_type' in params:
            query_params['filter_type'] = params['filter_type']
        if 'filter_published' in params:
            query_params['filter_published'] = params['filter_published']
        if 'filter_import_id' in params:
            query_params['filter_import_id'] = params['filter_import_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tag' in params:
            body_params = params['tag']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='int',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def batch_remove_tag_using_delete(self, tag, **kwargs):
        """
        Remove a tag from a batch of questions
        ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.batch_remove_tag_using_delete(tag, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str tag: The tag to remove (required)
        :param str filter_search: Filter for documents whose question, answers or tags contains provided string
        :param str filter_idset: Filter for documents whose id is in the comma separated list provided
        :param str filter_category: Filter for questions with specified category, by id
        :param str filter_tag: Filter for questions with specified tag
        :param str filter_tagset: Filter for questions with specified tags (separated by comma)
        :param str filter_type: Filter for questions with specified type.  Allowable values: ('TEXT', 'IMAGE', 'VIDEO', 'AUDIO')
        :param bool filter_published: Filter for questions currenctly published or not
        :param int filter_import_id: Filter for questions from a specific import job
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.batch_remove_tag_using_delete_with_http_info(tag, **kwargs)
        else:
            (data) = self.batch_remove_tag_using_delete_with_http_info(tag, **kwargs)
            return data

    def batch_remove_tag_using_delete_with_http_info(self, tag, **kwargs):
        """
        Remove a tag from a batch of questions
        ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.batch_remove_tag_using_delete_with_http_info(tag, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str tag: The tag to remove (required)
        :param str filter_search: Filter for documents whose question, answers or tags contains provided string
        :param str filter_idset: Filter for documents whose id is in the comma separated list provided
        :param str filter_category: Filter for questions with specified category, by id
        :param str filter_tag: Filter for questions with specified tag
        :param str filter_tagset: Filter for questions with specified tags (separated by comma)
        :param str filter_type: Filter for questions with specified type.  Allowable values: ('TEXT', 'IMAGE', 'VIDEO', 'AUDIO')
        :param bool filter_published: Filter for questions currenctly published or not
        :param int filter_import_id: Filter for questions from a specific import job
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tag', 'filter_search', 'filter_idset', 'filter_category', 'filter_tag', 'filter_tagset', 'filter_type', 'filter_published', 'filter_import_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method batch_remove_tag_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tag' is set
        if ('tag' not in params) or (params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `batch_remove_tag_using_delete`")


        collection_formats = {}

        resource_path = '/trivia/questions/tags/{tag}'.replace('{format}', 'json')
        path_params = {}
        if 'tag' in params:
            path_params['tag'] = params['tag']

        query_params = {}
        if 'filter_search' in params:
            query_params['filter_search'] = params['filter_search']
        if 'filter_idset' in params:
            query_params['filter_idset'] = params['filter_idset']
        if 'filter_category' in params:
            query_params['filter_category'] = params['filter_category']
        if 'filter_tag' in params:
            query_params['filter_tag'] = params['filter_tag']
        if 'filter_tagset' in params:
            query_params['filter_tagset'] = params['filter_tagset']
        if 'filter_type' in params:
            query_params['filter_type'] = params['filter_type']
        if 'filter_published' in params:
            query_params['filter_published'] = params['filter_published']
        if 'filter_import_id' in params:
            query_params['filter_import_id'] = params['filter_import_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='int',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def bulk_update_using_put(self, **kwargs):
        """
        Bulk update questions
        Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.bulk_update_using_put(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param QuestionResource question: New values for a set of question fields
        :param str filter_search: Filter for documents whose question, answers or tags contains provided string
        :param str filter_idset: Filter for documents whose id is in the comma separated list provided
        :param str filter_category: Filter for questions with specified category, by id
        :param str filter_tagset: Filter for questions with specified tags (separated by comma)
        :param str filter_type: Filter for questions with specified type.  Allowable values: ('TEXT', 'IMAGE', 'VIDEO', 'AUDIO')
        :param bool filter_published: Filter for questions currenctly published or not
        :param int filter_import_id: Filter for questions from a specific import job
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.bulk_update_using_put_with_http_info(**kwargs)
        else:
            (data) = self.bulk_update_using_put_with_http_info(**kwargs)
            return data

    def bulk_update_using_put_with_http_info(self, **kwargs):
        """
        Bulk update questions
        Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.bulk_update_using_put_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param QuestionResource question: New values for a set of question fields
        :param str filter_search: Filter for documents whose question, answers or tags contains provided string
        :param str filter_idset: Filter for documents whose id is in the comma separated list provided
        :param str filter_category: Filter for questions with specified category, by id
        :param str filter_tagset: Filter for questions with specified tags (separated by comma)
        :param str filter_type: Filter for questions with specified type.  Allowable values: ('TEXT', 'IMAGE', 'VIDEO', 'AUDIO')
        :param bool filter_published: Filter for questions currenctly published or not
        :param int filter_import_id: Filter for questions from a specific import job
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['question', 'filter_search', 'filter_idset', 'filter_category', 'filter_tagset', 'filter_type', 'filter_published', 'filter_import_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_update_using_put" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/trivia/questions'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'filter_search' in params:
            query_params['filter_search'] = params['filter_search']
        if 'filter_idset' in params:
            query_params['filter_idset'] = params['filter_idset']
        if 'filter_category' in params:
            query_params['filter_category'] = params['filter_category']
        if 'filter_tagset' in params:
            query_params['filter_tagset'] = params['filter_tagset']
        if 'filter_type' in params:
            query_params['filter_type'] = params['filter_type']
        if 'filter_published' in params:
            query_params['filter_published'] = params['filter_published']
        if 'filter_import_id' in params:
            query_params['filter_import_id'] = params['filter_import_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'question' in params:
            body_params = params['question']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='int',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def count_questions_using_get(self, **kwargs):
        """
        Count questions based on filters.
        This is also provided by the list endpoint so you don't need to call this for pagination purposes
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.count_questions_using_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str filter_search: Filter for documents whose question, answers or tags contains provided string
        :param str filter_idset: Filter for documents whose id is in the comma separated list provided
        :param str filter_category: Filter for questions with specified category, by id
        :param str filter_tag: Filter for questions with specified tag
        :param str filter_tagset: Filter for questions with specified tags (separated by comma)
        :param str filter_type: Filter for questions with specified type.  Allowable values: ('TEXT', 'IMAGE', 'VIDEO', 'AUDIO')
        :param bool filter_published: Filter for questions currenctly published or not
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.count_questions_using_get_with_http_info(**kwargs)
        else:
            (data) = self.count_questions_using_get_with_http_info(**kwargs)
            return data

    def count_questions_using_get_with_http_info(self, **kwargs):
        """
        Count questions based on filters.
        This is also provided by the list endpoint so you don't need to call this for pagination purposes
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.count_questions_using_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str filter_search: Filter for documents whose question, answers or tags contains provided string
        :param str filter_idset: Filter for documents whose id is in the comma separated list provided
        :param str filter_category: Filter for questions with specified category, by id
        :param str filter_tag: Filter for questions with specified tag
        :param str filter_tagset: Filter for questions with specified tags (separated by comma)
        :param str filter_type: Filter for questions with specified type.  Allowable values: ('TEXT', 'IMAGE', 'VIDEO', 'AUDIO')
        :param bool filter_published: Filter for questions currenctly published or not
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter_search', 'filter_idset', 'filter_category', 'filter_tag', 'filter_tagset', 'filter_type', 'filter_published']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method count_questions_using_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/trivia/questions/count'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'filter_search' in params:
            query_params['filter_search'] = params['filter_search']
        if 'filter_idset' in params:
            query_params['filter_idset'] = params['filter_idset']
        if 'filter_category' in params:
            query_params['filter_category'] = params['filter_category']
        if 'filter_tag' in params:
            query_params['filter_tag'] = params['filter_tag']
        if 'filter_tagset' in params:
            query_params['filter_tagset'] = params['filter_tagset']
        if 'filter_type' in params:
            query_params['filter_type'] = params['filter_type']
        if 'filter_published' in params:
            query_params['filter_published'] = params['filter_published']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='int',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_question_template_using_post(self, **kwargs):
        """
        Create a question template
        Question templates define a type of question and the properties they have
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_question_template_using_post(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param QuestionTemplateResource question_template_resource: The question template resource object
        :return: QuestionTemplateResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_question_template_using_post_with_http_info(**kwargs)
        else:
            (data) = self.create_question_template_using_post_with_http_info(**kwargs)
            return data

    def create_question_template_using_post_with_http_info(self, **kwargs):
        """
        Create a question template
        Question templates define a type of question and the properties they have
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_question_template_using_post_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param QuestionTemplateResource question_template_resource: The question template resource object
        :return: QuestionTemplateResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['question_template_resource']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_question_template_using_post" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/trivia/questions/templates'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'question_template_resource' in params:
            body_params = params['question_template_resource']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='QuestionTemplateResource',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_question_using_post(self, **kwargs):
        """
        Create a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_question_using_post(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param QuestionResource question: The new question
        :return: QuestionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_question_using_post_with_http_info(**kwargs)
        else:
            (data) = self.create_question_using_post_with_http_info(**kwargs)
            return data

    def create_question_using_post_with_http_info(self, **kwargs):
        """
        Create a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_question_using_post_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param QuestionResource question: The new question
        :return: QuestionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['question']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_question_using_post" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/trivia/questions'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'question' in params:
            body_params = params['question']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='QuestionResource',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_using_post(self, **kwargs):
        """
        Create an import job
        Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_using_post(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ImportJobResource request: The new import job
        :return: ImportJobResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_using_post_with_http_info(**kwargs)
        else:
            (data) = self.create_using_post_with_http_info(**kwargs)
            return data

    def create_using_post_with_http_info(self, **kwargs):
        """
        Create an import job
        Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_using_post_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ImportJobResource request: The new import job
        :return: ImportJobResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['request']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_using_post" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/trivia/import'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request' in params:
            body_params = params['request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ImportJobResource',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_question_template_using_delete(self, id, **kwargs):
        """
        Delete a question template
        If cascade = 'detach', it will force delete the template even if it's attached to other objects
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_question_template_using_delete(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The id of the template (required)
        :param str cascade: The value needed to delete used templates
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_question_template_using_delete_with_http_info(id, **kwargs)
        else:
            (data) = self.delete_question_template_using_delete_with_http_info(id, **kwargs)
            return data

    def delete_question_template_using_delete_with_http_info(self, id, **kwargs):
        """
        Delete a question template
        If cascade = 'detach', it will force delete the template even if it's attached to other objects
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_question_template_using_delete_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The id of the template (required)
        :param str cascade: The value needed to delete used templates
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'cascade']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_question_template_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_question_template_using_delete`")


        collection_formats = {}

        resource_path = '/trivia/questions/templates/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'cascade' in params:
            query_params['cascade'] = params['cascade']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_question_using_delete(self, id, **kwargs):
        """
        Delete a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_question_using_delete(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The id of the question (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_question_using_delete_with_http_info(id, **kwargs)
        else:
            (data) = self.delete_question_using_delete_with_http_info(id, **kwargs)
            return data

    def delete_question_using_delete_with_http_info(self, id, **kwargs):
        """
        Delete a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_question_using_delete_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The id of the question (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_question_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_question_using_delete`")


        collection_formats = {}

        resource_path = '/trivia/questions/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_using_delete(self, id, **kwargs):
        """
        Delete an import job
        Also deletes all questions that were imported by it
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_using_delete(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: The id of the job (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_using_delete_with_http_info(id, **kwargs)
        else:
            (data) = self.delete_using_delete_with_http_info(id, **kwargs)
            return data

    def delete_using_delete_with_http_info(self, id, **kwargs):
        """
        Delete an import job
        Also deletes all questions that were imported by it
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_using_delete_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: The id of the job (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_using_delete`")


        collection_formats = {}

        resource_path = '/trivia/import/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_answer_using_get(self, question_id, id, **kwargs):
        """
        Get an answer for a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_answer_using_get(question_id, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str question_id: The id of the question (required)
        :param str id: The id of the answer (required)
        :return: AnswerResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_answer_using_get_with_http_info(question_id, id, **kwargs)
        else:
            (data) = self.get_answer_using_get_with_http_info(question_id, id, **kwargs)
            return data

    def get_answer_using_get_with_http_info(self, question_id, id, **kwargs):
        """
        Get an answer for a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_answer_using_get_with_http_info(question_id, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str question_id: The id of the question (required)
        :param str id: The id of the answer (required)
        :return: AnswerResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['question_id', 'id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_answer_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'question_id' is set
        if ('question_id' not in params) or (params['question_id'] is None):
            raise ValueError("Missing the required parameter `question_id` when calling `get_answer_using_get`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_answer_using_get`")


        collection_formats = {}

        resource_path = '/trivia/questions/{question_id}/answers/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'question_id' in params:
            path_params['question_id'] = params['question_id']
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AnswerResource',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_answers_using_get(self, question_id, **kwargs):
        """
        List the answers available for a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_answers_using_get(question_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str question_id: The id of the question (required)
        :return: list[AnswerResource]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_answers_using_get_with_http_info(question_id, **kwargs)
        else:
            (data) = self.get_answers_using_get_with_http_info(question_id, **kwargs)
            return data

    def get_answers_using_get_with_http_info(self, question_id, **kwargs):
        """
        List the answers available for a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_answers_using_get_with_http_info(question_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str question_id: The id of the question (required)
        :return: list[AnswerResource]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['question_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_answers_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'question_id' is set
        if ('question_id' not in params) or (params['question_id'] is None):
            raise ValueError("Missing the required parameter `question_id` when calling `get_answers_using_get`")


        collection_formats = {}

        resource_path = '/trivia/questions/{question_id}/answers'.replace('{format}', 'json')
        path_params = {}
        if 'question_id' in params:
            path_params['question_id'] = params['question_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[AnswerResource]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_list_using_get1(self, **kwargs):
        """
        Get a list of import job
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_list_using_get1(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str filter_vendor: Filter for jobs by vendor id
        :param str filter_category: Filter for jobs by category id
        :param str filter_name: Filter for jobs which name *STARTS* with the given string
        :param str filter_status: Filter for jobs that are in a specific set of statuses (comma separated)
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :param str order: A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
        :return: PageResourceImportJobResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_list_using_get1_with_http_info(**kwargs)
        else:
            (data) = self.get_list_using_get1_with_http_info(**kwargs)
            return data

    def get_list_using_get1_with_http_info(self, **kwargs):
        """
        Get a list of import job
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_list_using_get1_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str filter_vendor: Filter for jobs by vendor id
        :param str filter_category: Filter for jobs by category id
        :param str filter_name: Filter for jobs which name *STARTS* with the given string
        :param str filter_status: Filter for jobs that are in a specific set of statuses (comma separated)
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :param str order: A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
        :return: PageResourceImportJobResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter_vendor', 'filter_category', 'filter_name', 'filter_status', 'size', 'page', 'order']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_list_using_get1" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/trivia/import'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'filter_vendor' in params:
            query_params['filter_vendor'] = params['filter_vendor']
        if 'filter_category' in params:
            query_params['filter_category'] = params['filter_category']
        if 'filter_name' in params:
            query_params['filter_name'] = params['filter_name']
        if 'filter_status' in params:
            query_params['filter_status'] = params['filter_status']
        if 'size' in params:
            query_params['size'] = params['size']
        if 'page' in params:
            query_params['page'] = params['page']
        if 'order' in params:
            query_params['order'] = params['order']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PageResourceImportJobResource',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_question_template_using_get(self, id, **kwargs):
        """
        Get a single question template
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_question_template_using_get(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The id of the template (required)
        :return: QuestionTemplateResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_question_template_using_get_with_http_info(id, **kwargs)
        else:
            (data) = self.get_question_template_using_get_with_http_info(id, **kwargs)
            return data

    def get_question_template_using_get_with_http_info(self, id, **kwargs):
        """
        Get a single question template
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_question_template_using_get_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The id of the template (required)
        :return: QuestionTemplateResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_question_template_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_question_template_using_get`")


        collection_formats = {}

        resource_path = '/trivia/questions/templates/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='QuestionTemplateResource',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_question_templates_using_get(self, **kwargs):
        """
        List and search question templates
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_question_templates_using_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :param str order: A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
        :return: PageResourceQuestionTemplateResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_question_templates_using_get_with_http_info(**kwargs)
        else:
            (data) = self.get_question_templates_using_get_with_http_info(**kwargs)
            return data

    def get_question_templates_using_get_with_http_info(self, **kwargs):
        """
        List and search question templates
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_question_templates_using_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :param str order: A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
        :return: PageResourceQuestionTemplateResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['size', 'page', 'order']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_question_templates_using_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/trivia/questions/templates'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'size' in params:
            query_params['size'] = params['size']
        if 'page' in params:
            query_params['page'] = params['page']
        if 'order' in params:
            query_params['order'] = params['order']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PageResourceQuestionTemplateResource',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_question_using_get(self, id, **kwargs):
        """
        Get a single question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_question_using_get(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The id of the question (required)
        :return: QuestionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_question_using_get_with_http_info(id, **kwargs)
        else:
            (data) = self.get_question_using_get_with_http_info(id, **kwargs)
            return data

    def get_question_using_get_with_http_info(self, id, **kwargs):
        """
        Get a single question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_question_using_get_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The id of the question (required)
        :return: QuestionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_question_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_question_using_get`")


        collection_formats = {}

        resource_path = '/trivia/questions/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='QuestionResource',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_questions_delta_using_get(self, **kwargs):
        """
        List question deltas in ascending order of updated date
        The 'since' parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_questions_delta_using_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int since: Timestamp in seconds
        :return: list[DeltaResource]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_questions_delta_using_get_with_http_info(**kwargs)
        else:
            (data) = self.get_questions_delta_using_get_with_http_info(**kwargs)
            return data

    def get_questions_delta_using_get_with_http_info(self, **kwargs):
        """
        List question deltas in ascending order of updated date
        The 'since' parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_questions_delta_using_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int since: Timestamp in seconds
        :return: list[DeltaResource]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['since']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_questions_delta_using_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/trivia/questions/delta'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'since' in params:
            query_params['since'] = params['since']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[DeltaResource]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_questions_using_get(self, **kwargs):
        """
        List and search questions
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_questions_using_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :param str order: A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
        :param str filter_search: Filter for documents whose question, answers or tags contains provided string
        :param str filter_idset: Filter for documents whose id is in the comma separated list provided
        :param str filter_category: Filter for questions with specified category, by id
        :param str filter_tagset: Filter for questions with specified tags (separated by comma)
        :param str filter_type: Filter for questions with specified type.  Allowable values: ('TEXT', 'IMAGE', 'VIDEO', 'AUDIO')
        :param bool filter_published: Filter for questions currenctly published or not
        :param int filter_import_id: Filter for questions from a specific import job
        :return: PageResourceQuestionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_questions_using_get_with_http_info(**kwargs)
        else:
            (data) = self.get_questions_using_get_with_http_info(**kwargs)
            return data

    def get_questions_using_get_with_http_info(self, **kwargs):
        """
        List and search questions
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_questions_using_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int size: The number of objects returned per page
        :param int page: The number of the page returned, starting with 1
        :param str order: A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
        :param str filter_search: Filter for documents whose question, answers or tags contains provided string
        :param str filter_idset: Filter for documents whose id is in the comma separated list provided
        :param str filter_category: Filter for questions with specified category, by id
        :param str filter_tagset: Filter for questions with specified tags (separated by comma)
        :param str filter_type: Filter for questions with specified type.  Allowable values: ('TEXT', 'IMAGE', 'VIDEO', 'AUDIO')
        :param bool filter_published: Filter for questions currenctly published or not
        :param int filter_import_id: Filter for questions from a specific import job
        :return: PageResourceQuestionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['size', 'page', 'order', 'filter_search', 'filter_idset', 'filter_category', 'filter_tagset', 'filter_type', 'filter_published', 'filter_import_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_questions_using_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/trivia/questions'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'size' in params:
            query_params['size'] = params['size']
        if 'page' in params:
            query_params['page'] = params['page']
        if 'order' in params:
            query_params['order'] = params['order']
        if 'filter_search' in params:
            query_params['filter_search'] = params['filter_search']
        if 'filter_idset' in params:
            query_params['filter_idset'] = params['filter_idset']
        if 'filter_category' in params:
            query_params['filter_category'] = params['filter_category']
        if 'filter_tagset' in params:
            query_params['filter_tagset'] = params['filter_tagset']
        if 'filter_type' in params:
            query_params['filter_type'] = params['filter_type']
        if 'filter_published' in params:
            query_params['filter_published'] = params['filter_published']
        if 'filter_import_id' in params:
            query_params['filter_import_id'] = params['filter_import_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='PageResourceQuestionResource',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_tags_using_get1(self, id, **kwargs):
        """
        List the tags for a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_tags_using_get1(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The id of the question (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_tags_using_get1_with_http_info(id, **kwargs)
        else:
            (data) = self.get_tags_using_get1_with_http_info(id, **kwargs)
            return data

    def get_tags_using_get1_with_http_info(self, id, **kwargs):
        """
        List the tags for a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_tags_using_get1_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The id of the question (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tags_using_get1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_tags_using_get1`")


        collection_formats = {}

        resource_path = '/trivia/questions/{id}/tags'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[str]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_tags_using_get2(self, **kwargs):
        """
        List and search tags by the beginning of the string
        For performance reasons, search & category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_tags_using_get2(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str filter_search: Filter for tags starting with the given text
        :param str filter_category: Filter for tags on questions from a specific category
        :param int filter_import_id: Filter for tags on questions from a specific import job
        :return: Collectionstring
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_tags_using_get2_with_http_info(**kwargs)
        else:
            (data) = self.get_tags_using_get2_with_http_info(**kwargs)
            return data

    def get_tags_using_get2_with_http_info(self, **kwargs):
        """
        List and search tags by the beginning of the string
        For performance reasons, search & category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_tags_using_get2_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str filter_search: Filter for tags starting with the given text
        :param str filter_category: Filter for tags on questions from a specific category
        :param int filter_import_id: Filter for tags on questions from a specific import job
        :return: Collectionstring
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter_search', 'filter_category', 'filter_import_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tags_using_get2" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/trivia/tags'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'filter_search' in params:
            query_params['filter_search'] = params['filter_search']
        if 'filter_category' in params:
            query_params['filter_category'] = params['filter_category']
        if 'filter_import_id' in params:
            query_params['filter_import_id'] = params['filter_import_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Collectionstring',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_using_get(self, id, **kwargs):
        """
        Get an import job
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_using_get(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: The id of the job (required)
        :return: ImportJobResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_using_get_with_http_info(id, **kwargs)
        else:
            (data) = self.get_using_get_with_http_info(id, **kwargs)
            return data

    def get_using_get_with_http_info(self, id, **kwargs):
        """
        Get an import job
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_using_get_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: The id of the job (required)
        :return: ImportJobResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_using_get`")


        collection_formats = {}

        resource_path = '/trivia/import/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ImportJobResource',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def remove_answers_using_delete(self, question_id, id, **kwargs):
        """
        Remove an answer from a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.remove_answers_using_delete(question_id, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str question_id: The id of the question (required)
        :param str id: The id of the answer (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.remove_answers_using_delete_with_http_info(question_id, id, **kwargs)
        else:
            (data) = self.remove_answers_using_delete_with_http_info(question_id, id, **kwargs)
            return data

    def remove_answers_using_delete_with_http_info(self, question_id, id, **kwargs):
        """
        Remove an answer from a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.remove_answers_using_delete_with_http_info(question_id, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str question_id: The id of the question (required)
        :param str id: The id of the answer (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['question_id', 'id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_answers_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'question_id' is set
        if ('question_id' not in params) or (params['question_id'] is None):
            raise ValueError("Missing the required parameter `question_id` when calling `remove_answers_using_delete`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `remove_answers_using_delete`")


        collection_formats = {}

        resource_path = '/trivia/questions/{question_id}/answers/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'question_id' in params:
            path_params['question_id'] = params['question_id']
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def remove_tag_using_delete(self, id, tag, **kwargs):
        """
        Remove a tag from a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.remove_tag_using_delete(id, tag, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The id of the question (required)
        :param str tag: The tag to remove (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.remove_tag_using_delete_with_http_info(id, tag, **kwargs)
        else:
            (data) = self.remove_tag_using_delete_with_http_info(id, tag, **kwargs)
            return data

    def remove_tag_using_delete_with_http_info(self, id, tag, **kwargs):
        """
        Remove a tag from a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.remove_tag_using_delete_with_http_info(id, tag, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The id of the question (required)
        :param str tag: The tag to remove (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'tag']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_tag_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `remove_tag_using_delete`")
        # verify the required parameter 'tag' is set
        if ('tag' not in params) or (params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `remove_tag_using_delete`")


        collection_formats = {}

        resource_path = '/trivia/questions/{id}/tags/{tag}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']
        if 'tag' in params:
            path_params['tag'] = params['tag']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def start_process_using_post(self, id, publish_now, **kwargs):
        """
        Start processing an import job
        Will process the CSV file and add new questions asynchronously. The status of the job must be 'VALID'.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.start_process_using_post(id, publish_now, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: The id of the job (required)
        :param bool publish_now: Whether the new questions should be published live immediately (required)
        :return: ImportJobResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.start_process_using_post_with_http_info(id, publish_now, **kwargs)
        else:
            (data) = self.start_process_using_post_with_http_info(id, publish_now, **kwargs)
            return data

    def start_process_using_post_with_http_info(self, id, publish_now, **kwargs):
        """
        Start processing an import job
        Will process the CSV file and add new questions asynchronously. The status of the job must be 'VALID'.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.start_process_using_post_with_http_info(id, publish_now, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: The id of the job (required)
        :param bool publish_now: Whether the new questions should be published live immediately (required)
        :return: ImportJobResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'publish_now']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_process_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `start_process_using_post`")
        # verify the required parameter 'publish_now' is set
        if ('publish_now' not in params) or (params['publish_now'] is None):
            raise ValueError("Missing the required parameter `publish_now` when calling `start_process_using_post`")


        collection_formats = {}

        resource_path = '/trivia/import/{id}/process'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'publish_now' in params:
            query_params['publish_now'] = params['publish_now']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ImportJobResource',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_answer_using_put(self, question_id, id, **kwargs):
        """
        Update an answer for a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_answer_using_put(question_id, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str question_id: The id of the question (required)
        :param str id: The id of the answer (required)
        :param AnswerResource answer: The updated answer
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_answer_using_put_with_http_info(question_id, id, **kwargs)
        else:
            (data) = self.update_answer_using_put_with_http_info(question_id, id, **kwargs)
            return data

    def update_answer_using_put_with_http_info(self, question_id, id, **kwargs):
        """
        Update an answer for a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_answer_using_put_with_http_info(question_id, id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str question_id: The id of the question (required)
        :param str id: The id of the answer (required)
        :param AnswerResource answer: The updated answer
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['question_id', 'id', 'answer']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_answer_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'question_id' is set
        if ('question_id' not in params) or (params['question_id'] is None):
            raise ValueError("Missing the required parameter `question_id` when calling `update_answer_using_put`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_answer_using_put`")


        collection_formats = {}

        resource_path = '/trivia/questions/{question_id}/answers/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'question_id' in params:
            path_params['question_id'] = params['question_id']
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'answer' in params:
            body_params = params['answer']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_question_template_using_put(self, id, **kwargs):
        """
        Update a question template
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_question_template_using_put(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The id of the template (required)
        :param QuestionTemplateResource question_template_resource: The question template resource object
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_question_template_using_put_with_http_info(id, **kwargs)
        else:
            (data) = self.update_question_template_using_put_with_http_info(id, **kwargs)
            return data

    def update_question_template_using_put_with_http_info(self, id, **kwargs):
        """
        Update a question template
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_question_template_using_put_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The id of the template (required)
        :param QuestionTemplateResource question_template_resource: The question template resource object
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'question_template_resource']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_question_template_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_question_template_using_put`")


        collection_formats = {}

        resource_path = '/trivia/questions/templates/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'question_template_resource' in params:
            body_params = params['question_template_resource']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_question_using_put(self, id, **kwargs):
        """
        Update a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_question_using_put(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The id of the question (required)
        :param QuestionResource question: The updated question
        :return: QuestionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_question_using_put_with_http_info(id, **kwargs)
        else:
            (data) = self.update_question_using_put_with_http_info(id, **kwargs)
            return data

    def update_question_using_put_with_http_info(self, id, **kwargs):
        """
        Update a question
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_question_using_put_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The id of the question (required)
        :param QuestionResource question: The updated question
        :return: QuestionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'question']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_question_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_question_using_put`")


        collection_formats = {}

        resource_path = '/trivia/questions/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'question' in params:
            body_params = params['question']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='QuestionResource',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_using_put(self, id, **kwargs):
        """
        Update an import job
        Changes should be made before process is started for there to be any effect.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_using_put(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: The id of the job (required)
        :param ImportJobResource request: The updated job
        :return: ImportJobResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_using_put_with_http_info(id, **kwargs)
        else:
            (data) = self.update_using_put_with_http_info(id, **kwargs)
            return data

    def update_using_put_with_http_info(self, id, **kwargs):
        """
        Update an import job
        Changes should be made before process is started for there to be any effect.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_using_put_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: The id of the job (required)
        :param ImportJobResource request: The updated job
        :return: ImportJobResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'request']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_using_put`")


        collection_formats = {}

        resource_path = '/trivia/import/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request' in params:
            body_params = params['request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ImportJobResource',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
