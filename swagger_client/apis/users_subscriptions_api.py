# coding: utf-8

"""
    Knetik Platform API Documentation latest 

    This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://demo.sandbox.knetikcloud.com

    OpenAPI spec version: latest 
    Contact: support@knetik.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class UsersSubscriptionsApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def get_subscription_details_using_get(self, user_id, inventory_id, **kwargs):
        """
        Get details about a user's subscription
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscription_details_using_get(user_id, inventory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :return: InventorySubscriptionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_subscription_details_using_get_with_http_info(user_id, inventory_id, **kwargs)
        else:
            (data) = self.get_subscription_details_using_get_with_http_info(user_id, inventory_id, **kwargs)
            return data

    def get_subscription_details_using_get_with_http_info(self, user_id, inventory_id, **kwargs):
        """
        Get details about a user's subscription
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscription_details_using_get_with_http_info(user_id, inventory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :return: InventorySubscriptionResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'inventory_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subscription_details_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `get_subscription_details_using_get`")
        # verify the required parameter 'inventory_id' is set
        if ('inventory_id' not in params) or (params['inventory_id'] is None):
            raise ValueError("Missing the required parameter `inventory_id` when calling `get_subscription_details_using_get`")


        collection_formats = {}

        resource_path = '/users/{user_id}/subscriptions/{inventory_id}'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']
        if 'inventory_id' in params:
            path_params['inventory_id'] = params['inventory_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='InventorySubscriptionResource',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_subscription_details_using_get1(self, user_id, **kwargs):
        """
        Get details about a user's subscriptions
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscription_details_using_get1(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: The id of the user (required)
        :return: list[InventorySubscriptionResource]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_subscription_details_using_get1_with_http_info(user_id, **kwargs)
        else:
            (data) = self.get_subscription_details_using_get1_with_http_info(user_id, **kwargs)
            return data

    def get_subscription_details_using_get1_with_http_info(self, user_id, **kwargs):
        """
        Get details about a user's subscriptions
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscription_details_using_get1_with_http_info(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: The id of the user (required)
        :return: list[InventorySubscriptionResource]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subscription_details_using_get1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `get_subscription_details_using_get1`")


        collection_formats = {}

        resource_path = '/users/{user_id}/subscriptions'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[InventorySubscriptionResource]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def reactivate_using_post(self, user_id, inventory_id, **kwargs):
        """
        Reactivate a subscription and charge fee
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.reactivate_using_post(user_id, inventory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :param ReactivateSubscriptionRequest reactivate_subscription_request: The reactivate subscription request object inventory
        :return: InvoiceResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.reactivate_using_post_with_http_info(user_id, inventory_id, **kwargs)
        else:
            (data) = self.reactivate_using_post_with_http_info(user_id, inventory_id, **kwargs)
            return data

    def reactivate_using_post_with_http_info(self, user_id, inventory_id, **kwargs):
        """
        Reactivate a subscription and charge fee
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.reactivate_using_post_with_http_info(user_id, inventory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :param ReactivateSubscriptionRequest reactivate_subscription_request: The reactivate subscription request object inventory
        :return: InvoiceResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'inventory_id', 'reactivate_subscription_request']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reactivate_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `reactivate_using_post`")
        # verify the required parameter 'inventory_id' is set
        if ('inventory_id' not in params) or (params['inventory_id'] is None):
            raise ValueError("Missing the required parameter `inventory_id` when calling `reactivate_using_post`")


        collection_formats = {}

        resource_path = '/users/{user_id}/subscriptions/{inventory_id}/reactivate'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']
        if 'inventory_id' in params:
            path_params['inventory_id'] = params['inventory_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'reactivate_subscription_request' in params:
            body_params = params['reactivate_subscription_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='InvoiceResource',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def set_bill_date_using_put(self, user_id, inventory_id, bill_date, **kwargs):
        """
        Set a new date to bill a subscription on
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_bill_date_using_put(user_id, inventory_id, bill_date, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :param int bill_date: The new bill date. Unix timestamp in seconds (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.set_bill_date_using_put_with_http_info(user_id, inventory_id, bill_date, **kwargs)
        else:
            (data) = self.set_bill_date_using_put_with_http_info(user_id, inventory_id, bill_date, **kwargs)
            return data

    def set_bill_date_using_put_with_http_info(self, user_id, inventory_id, bill_date, **kwargs):
        """
        Set a new date to bill a subscription on
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_bill_date_using_put_with_http_info(user_id, inventory_id, bill_date, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :param int bill_date: The new bill date. Unix timestamp in seconds (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'inventory_id', 'bill_date']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_bill_date_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `set_bill_date_using_put`")
        # verify the required parameter 'inventory_id' is set
        if ('inventory_id' not in params) or (params['inventory_id'] is None):
            raise ValueError("Missing the required parameter `inventory_id` when calling `set_bill_date_using_put`")
        # verify the required parameter 'bill_date' is set
        if ('bill_date' not in params) or (params['bill_date'] is None):
            raise ValueError("Missing the required parameter `bill_date` when calling `set_bill_date_using_put`")


        collection_formats = {}

        resource_path = '/users/{user_id}/subscriptions/{inventory_id}/bill-date'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']
        if 'inventory_id' in params:
            path_params['inventory_id'] = params['inventory_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'bill_date' in params:
            body_params = params['bill_date']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def set_payment_method_using_put(self, user_id, inventory_id, **kwargs):
        """
        Set the payment method to use for a subscription
        May send null to use floating default
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_payment_method_using_put(user_id, inventory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :param int payment_method_id: The id of the payment method
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.set_payment_method_using_put_with_http_info(user_id, inventory_id, **kwargs)
        else:
            (data) = self.set_payment_method_using_put_with_http_info(user_id, inventory_id, **kwargs)
            return data

    def set_payment_method_using_put_with_http_info(self, user_id, inventory_id, **kwargs):
        """
        Set the payment method to use for a subscription
        May send null to use floating default
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_payment_method_using_put_with_http_info(user_id, inventory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :param int payment_method_id: The id of the payment method
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'inventory_id', 'payment_method_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_payment_method_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `set_payment_method_using_put`")
        # verify the required parameter 'inventory_id' is set
        if ('inventory_id' not in params) or (params['inventory_id'] is None):
            raise ValueError("Missing the required parameter `inventory_id` when calling `set_payment_method_using_put`")


        collection_formats = {}

        resource_path = '/users/{user_id}/subscriptions/{inventory_id}/payment-method'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']
        if 'inventory_id' in params:
            path_params['inventory_id'] = params['inventory_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payment_method_id' in params:
            body_params = params['payment_method_id']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def set_status_using_put(self, user_id, inventory_id, status, **kwargs):
        """
        Set the status of a subscription
        The body is a json string (put in quotes) that should match a desired invoice status type. Note that the new status may be blocked if the system is not configured to allow the current status to be changed to the new, to enforce proper flow. The default options for statuses are shown below but may be altered for special use cases
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_status_using_put(user_id, inventory_id, status, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :param str status: The new status for the subscription. Actual options may differ from the indicated set if the invoice status type data has been altered.  Allowable values: ('current', 'canceled', 'stopped', 'payment_failed', 'suspended') (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.set_status_using_put_with_http_info(user_id, inventory_id, status, **kwargs)
        else:
            (data) = self.set_status_using_put_with_http_info(user_id, inventory_id, status, **kwargs)
            return data

    def set_status_using_put_with_http_info(self, user_id, inventory_id, status, **kwargs):
        """
        Set the status of a subscription
        The body is a json string (put in quotes) that should match a desired invoice status type. Note that the new status may be blocked if the system is not configured to allow the current status to be changed to the new, to enforce proper flow. The default options for statuses are shown below but may be altered for special use cases
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_status_using_put_with_http_info(user_id, inventory_id, status, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :param str status: The new status for the subscription. Actual options may differ from the indicated set if the invoice status type data has been altered.  Allowable values: ('current', 'canceled', 'stopped', 'payment_failed', 'suspended') (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'inventory_id', 'status']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_status_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `set_status_using_put`")
        # verify the required parameter 'inventory_id' is set
        if ('inventory_id' not in params) or (params['inventory_id'] is None):
            raise ValueError("Missing the required parameter `inventory_id` when calling `set_status_using_put`")
        # verify the required parameter 'status' is set
        if ('status' not in params) or (params['status'] is None):
            raise ValueError("Missing the required parameter `status` when calling `set_status_using_put`")


        collection_formats = {}

        resource_path = '/users/{user_id}/subscriptions/{inventory_id}/status'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']
        if 'inventory_id' in params:
            path_params['inventory_id'] = params['inventory_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'status' in params:
            body_params = params['status']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def set_user_plan_using_put(self, user_id, inventory_id, **kwargs):
        """
        Set a new subscription plan for a user
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_user_plan_using_put(user_id, inventory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :param str plan_id: The id of the new plan. Must be from the same subscription
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.set_user_plan_using_put_with_http_info(user_id, inventory_id, **kwargs)
        else:
            (data) = self.set_user_plan_using_put_with_http_info(user_id, inventory_id, **kwargs)
            return data

    def set_user_plan_using_put_with_http_info(self, user_id, inventory_id, **kwargs):
        """
        Set a new subscription plan for a user
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_user_plan_using_put_with_http_info(user_id, inventory_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: The id of the user (required)
        :param int inventory_id: The id of the user's inventory (required)
        :param str plan_id: The id of the new plan. Must be from the same subscription
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'inventory_id', 'plan_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_user_plan_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `set_user_plan_using_put`")
        # verify the required parameter 'inventory_id' is set
        if ('inventory_id' not in params) or (params['inventory_id'] is None):
            raise ValueError("Missing the required parameter `inventory_id` when calling `set_user_plan_using_put`")


        collection_formats = {}

        resource_path = '/users/{user_id}/subscriptions/{inventory_id}/plan'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']
        if 'inventory_id' in params:
            path_params['inventory_id'] = params['inventory_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'plan_id' in params:
            body_params = params['plan_id']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['knetik_oauth']

        return self.api_client.call_api(resource_path, 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
